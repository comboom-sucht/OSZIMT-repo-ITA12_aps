{"version":3,"sources":[".././node_modules/adm-zip/adm-zip.js",".././node_modules/adm-zip/headers/entryHeader.js",".././node_modules/adm-zip/headers/index.js",".././node_modules/adm-zip/headers/mainHeader.js",".././node_modules/adm-zip/methods/deflater.js",".././node_modules/adm-zip/methods/index.js",".././node_modules/adm-zip/methods/inflater.js",".././node_modules/adm-zip/util/constants.js",".././node_modules/adm-zip/util/errors.js",".././node_modules/adm-zip/util/fattr.js",".././node_modules/adm-zip/util/fileSystem.js",".././node_modules/adm-zip/util/index.js",".././node_modules/adm-zip/util/utils.js",".././node_modules/adm-zip/zipEntry.js",".././node_modules/adm-zip/zipFile.js","../external \"http\"","../external \"url\"","../external \"https\"",".././node_modules/node-fetch/lib/index.mjs",".././src/commands/generateProject.ts",".././src/constants.ts",".././src/extension.ts",".././src/util/mpStarterApi.ts",".././src/util/util.ts",".././src/util/vscodePrompts.ts","../external \"fs\"","../external \"path\"","../external \"stream\"","../external \"util\"","../external \"vscode\"","../external \"zlib\"","../webpack/bootstrap","../webpack/startup","../webpack/runtime/define property getters","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object"],"names":["Utils","fs","FileSystem","require","pth","existsSync","ZipEntry","ZipFile","test","process","platform","module","exports","input","_zip","undefined","_filename","Errors","INVALID_FILENAME","Constants","FILE","Buffer","isBuffer","BUFFER","NONE","sanitize","prefix","name","resolve","normalize","parts","split","i","l","length","path","join","slice","sep","indexOf","basename","getEntry","entry","item","entryName","header","readFile","getData","readFileAsync","callback","getDataAsync","readAsText","encoding","data","toString","readAsTextAsync","err","deleteFile","deleteEntry","addZipComment","comment","getZipComment","addZipEntryComment","getZipEntryComment","updateFile","content","setData","addLocalFile","localPath","zipPath","zipName","FILE_NOT_FOUND","replace","charAt","p","pop","this","addFile","readFileSync","addLocalFolder","filter","RegExp","filename","items","findFiles","self","forEach","alloc","addLocalFolderAsync","open","fd","code","next","attr","isDirectory","setEntry","getEntries","entries","getEntryCount","extractEntryTo","targetPath","maintainEntryPath","overwrite","NO_ENTRY","target","getEntryChildren","child","CANT_EXTRACT_FILE","childName","writeFileTo","CANT_OVERRIDE","extractAllTo","NO_ZIP","makeDir","utimesSync","time","extractAllToAsync","writeFileToAsync","succ","Error","writeZip","targetFileName","arguments","zipData","compressToBuffer","ok","toBuffer","onSuccess","onFail","onItemStart","onItemEnd","valueOf","toAsyncBuffer","_verMade","_version","_flags","_method","_time","_crc","_compressedSize","_size","_fnameLen","_extraLen","_comLen","_diskStart","_inattr","_attr","_offset","_dataHeader","setTime","val","Date","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","CENHDR","LOCHDR","fnameLen","extraLen","loadDataHeaderFromBinary","readUInt32LE","LOCSIG","INVALID_LOC","version","readUInt16LE","LOCVER","flags","LOCFLG","method","LOCHOW","LOCTIM","crc","LOCCRC","compressedSize","LOCSIZ","size","LOCLEN","LOCNAM","LOCEXT","loadFromBinary","CENSIG","INVALID_CEN","CENVEM","CENVER","CENFLG","CENHOW","CENTIM","CENCRC","CENSIZ","CENLEN","CENNAM","CENEXT","CENCOM","CENDSK","CENATT","CENATX","CENOFF","dataHeaderToBinary","writeUInt32LE","writeUInt16LE","entryHeaderToBinary","fill","methodToString","toUpperCase","EntryHeader","MainHeader","_volumeEntries","_totalEntries","_commentLength","ENDHDR","ENDSIG","ZIP64HDR","ZIP64SIG","INVALID_END","ENDSUB","ENDTOT","ENDSIZ","ENDOFF","ENDCOM","readBigUInt64LE","ZIP64SUB","ZIP64TOT","ZIP64SIZ","ZIP64OFF","toBinary","b","inbuf","zlib","opts","chunkSize","parseInt","deflate","deflateRawSync","deflateAsync","tmp","createDeflateRaw","total","on","push","buf","written","part","copy","end","Deflater","Inflater","inflate","inflateRawSync","inflateAsync","createInflateRaw","EXTSIG","EXTHDR","EXTCRC","EXTSIZ","EXTLEN","END64HDR","END64SIG","END64START","END64OFF","END64NUMDISKS","ZIP64LEAD","ZIP64SIZE","ZIP64VEM","ZIP64VER","ZIP64DSK","ZIP64DSKDIR","ZIP64SIZB","ZIP64EXTRA","STORED","SHRUNK","REDUCED1","REDUCED2","REDUCED3","REDUCED4","IMPLODED","DEFLATED","ENHANCED_DEFLATED","PKWARE","BZIP2","LZMA","IBM_TERSE","IBM_LZ77","FLG_ENC","FLG_COMP1","FLG_COMP2","FLG_DESC","FLG_ENH","FLG_STR","FLG_LNG","FLG_MSK","EF_ID","EF_SIZE","ID_ZIP64","ID_AVINFO","ID_PFS","ID_OS2","ID_NTFS","ID_OPENVMS","ID_UNIX","ID_FORK","ID_PATCH","ID_X509_PKCS7","ID_X509_CERTID_F","ID_X509_CERTID_C","ID_STRONGENC","ID_RECORD_MGT","ID_X509_PKCS7_RL","ID_IBM1","ID_IBM2","ID_POSZIP","EF_ZIP64_OR_32","EF_ZIP64_OR_16","EF_ZIP64_SUNCOMP","EF_ZIP64_SCOMP","EF_ZIP64_RHO","EF_ZIP64_DSN","_path","_obj","directory","readonly","hidden","executable","mtime","atime","_stat","statSync","mode","console","warn","decodeAttributes","encodeAttributes","versions","originalFs","Object","keys","e","FileAttr","crcTable","PATH_SEPARATOR","mkdirSync","resolvedPath","substr","stat","isFile","FILE_IN_THE_WAY","findSync","dir","pattern","recoursive","files","readdirSync","file","concat","crc32","n","c","k","writeInt32LE","off","len","c1","folder","dirname","openSync","chmodSync","writeSync","closeSync","exists","chmod","write","close","getAttributes","setAttributes","from","buffer","index","swap64","Headers","Methods","_entryHeader","_entryName","_comment","_isDirectory","uncompressedData","_extra","getCompressedDataFromZip","realDataOffset","crc32OK","dataHeader","decompress","async","pass","DIRECTORY_CONTENT_ERROR","compressedData","BAD_CRC","inflater","result","UNKNOWN_METHOD","compress","deflater","deflated","readUInt64LE","offset","parseZip64ExtendedInformation","diskNumStart","lastChar","fileNameLength","extraLength","signature","parseExtra","commentLength","getCompressedData","getCompressedDataAsync","value","changed","packHeader","inputType","entryList","entryTable","inBuffer","mainHeader","loadedEntries","readEntries","Array","diskEntries","extra","entryHeaderSize","readMainHeader","max","Math","endStart","endOffset","commentEnd","INVALID_FORMAT","totalEntries","iterateEntries","_self","splice","list","zipEntry","sort","a","nameA","toLowerCase","nameB","totalSize","dataBlock","entryHeaders","dindex","entryNameLen","rawEntryName","postHeader","dataLength","entryHeader","mainHeaderSize","outBuffer","mh","callee","Readable","Symbol","TYPE","Blob","blobParts","options","buffers","Number","element","ArrayBuffer","isView","byteOffset","byteLength","String","type","Promise","ab","readable","_read","start","relativeStart","relativeEnd","min","span","slicedBuffer","blob","FetchError","message","systemError","call","errno","captureStackTrace","constructor","convert","defineProperties","prototype","enumerable","defineProperty","toStringTag","writable","configurable","create","INTERNALS","PassThrough","Body","body","_this","_ref","_ref$size","_ref$timeout","timeout","isURLSearchParams","isBlob","disturbed","error","url","consumeBody","_this4","reject","TypeError","stream","accum","accumBytes","abort","resTimeout","setTimeout","chunk","clearTimeout","obj","append","delete","get","getAll","has","set","arrayBuffer","clone","instance","p1","p2","bodyUsed","getBoundary","pipe","extractContentType","getTotalBytes","getLengthSync","_lengthRetrievers","hasKnownLength","then","ct","headers","assign","_this2","JSON","parse","_this3","res","str","charset","exec","convertBody","json","text","mixIn","proto","getOwnPropertyNames","desc","getOwnPropertyDescriptor","global","invalidTokenRegex","invalidHeaderCharRegex","validateName","validateValue","find","map","key","MAP","init","rawHeaders","raw","headerNames","headerName","iterator","pairs","pair","thisArg","getHeaders","_pairs$i","createHeadersIterator","kind","values","INTERNAL","HeadersIteratorPrototype","setPrototypeOf","getPrototypeOf","_INTERNAL","done","exportNodeCompatibleHeaders","__proto__","hostHeaderKey","INTERNALS$1","STATUS_CODES","Response","status","contentType","statusText","counter","redirected","INTERNALS$2","parse_url","format_url","streamDestructionSupported","isRequest","Request","parsedURL","href","inputBody","signal","isAbortSignal","redirect","follow","agent","AbortError","PassThrough$1","resolve_url","fetch","request","protocol","hostname","contentLengthValue","totalBytes","getNodeRequestOptions","send","response","destroy","emit","aborted","abortAndFinalize","finalize","req","reqTimeout","removeEventListener","addEventListener","once","socket","isArray","createHeadersLenient","isRedirect","statusCode","location","locationURL","requestOpts","response_options","statusMessage","codings","zlibOptions","flush","finishFlush","dest","writeToStream","mpSupportMatrix","mpStarterApi","getSupportMatrix","mpConfigurations","configs","allMpVersions","groupId","prompts","askForGroupID","artifactId","askForArtifactID","mpVersion","askForMPVersion","mpServer","askForMPServer","supportedServers","buildTools","javaSEVersions","mpSpecs","getSupportedJavaAndSpecs","javaSEVersion","askForJavaSEVersion","buildTool","askForBuildTool","specDescriptions","descriptions","mpSpecifications","askForMPSpecifications","targetFolder","askForTargetFolder","targetDirString","fsPath","projectOptions","supportedServer","selectedSpecs","vscode","window","withProgress","ProgressLocation","Notification","title","cancellable","downloadMPStarterProjectZip","targetDirFolder","util","unzipFile","ERRORS","EXTRACT_PROJECT_ERROR","showErrorMessage","uriPath","Uri","selection","showInformationMessage","OPEN_NEW_PROJECT_OPTIONS","ADD_CURRENT_WORKSPACE","OPEN_NEW_WINDOW","workspace","updateWorkspaceFolders","uri","commands","executeCommand","FETCH_ERROR","MP_STARTER_API_ROOT","MP_VERSION_LABELS","MP40","MP33","MP32","MP30","MP22","MP21","MP20","MP14","MP13","MP12","MP_SERVER_LABELS","LIBERTY","HELIDON","PAYARA_MICRO","THORNTAIL_V2","KUMULUZEE","TOMEE","WILDFLY","WILDFLY_SWARM","QUARKUS","EXTENSION_USER_AGENT","CONFIRM_OPTIONS","YES","NO","context","subscriptions","registerCommand","generateProject","mpSupportResponse","serverName","microprofileVersion","serverSupportResponse","supportDetails","supportRecord","downloadLocation","requestOptions","stringify","downloadFile","pipeline","createWriteStream","deleteFolder","parent","currentPath","lstatSync","unlinkSync","rmdirSync","workspaceFolders","promisify","unlink","newStr","trim","targetDir","admZip","zipFolderExists","askForFolder","customOptions","showOpenDialog","canSelectFiles","canSelectFolders","canSelectMany","askConfirmation","showWarningMessage","showInputBox","placeHolder","prompt","ignoreFocusOut","validateInput","validateGroupId","validateArtifactId","supportedJavaSEVersions","showQuickPick","supportedBuildTools","supportedBuildToolsOptions","lower","formattedBuildTool","substring","buildToolQuickPickResult","mpVersions","mpVersionOptions","label","mpVersionQuickPickResult","mpServers","mpServerOptions","server","specs","mpSpecOptions","spec","fullDescription","detail","trimCapitalizeFirstLetter","specResults","canPickMany","openLabel","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","d","definition","o","prop","hasOwnProperty","r"],"mappings":"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","file":"extension.js","sourcesContent":["var Utils = require(\"./util\");\r\nvar fs = Utils.FileSystem.require(),\r\n\tpth = require(\"path\");\r\n\r\nfs.existsSync = fs.existsSync || pth.existsSync;\r\n\r\nvar ZipEntry = require(\"./zipEntry\"),\r\n\tZipFile = require(\"./zipFile\");\r\n\r\nvar isWin = /^win/.test(process.platform);\r\n\r\n\r\nmodule.exports = function (/**String*/input) {\r\n\tvar _zip = undefined,\r\n\t\t_filename = \"\";\r\n\r\n\tif (input && typeof input === \"string\") { // load zip file\r\n\t\tif (fs.existsSync(input)) {\r\n\t\t\t_filename = input;\r\n\t\t\t_zip = new ZipFile(input, Utils.Constants.FILE);\r\n\t\t} else {\r\n\t\t\tthrow Utils.Errors.INVALID_FILENAME;\r\n\t\t}\r\n\t} else if (input && Buffer.isBuffer(input)) { // load buffer\r\n\t\t_zip = new ZipFile(input, Utils.Constants.BUFFER);\r\n\t} else { // create new zip file\r\n\t\t_zip = new ZipFile(null, Utils.Constants.NONE);\r\n\t}\r\n\r\n\tfunction sanitize(prefix, name) {\r\n\t\tprefix = pth.resolve(pth.normalize(prefix));\r\n\t\tvar parts = name.split('/');\r\n\t\tfor (var i = 0, l = parts.length; i < l; i++) {\r\n\t\t\tvar path = pth.normalize(pth.join(prefix, parts.slice(i, l).join(pth.sep)));\r\n\t\t\tif (path.indexOf(prefix) === 0) {\r\n\t\t\t\treturn path;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn pth.normalize(pth.join(prefix, pth.basename(name)));\r\n\t}\r\n\r\n\tfunction getEntry(/**Object*/entry) {\r\n\t\tif (entry && _zip) {\r\n\t\t\tvar item;\r\n\t\t\t// If entry was given as a file name\r\n\t\t\tif (typeof entry === \"string\")\r\n\t\t\t\titem = _zip.getEntry(entry);\r\n\t\t\t// if entry was given as a ZipEntry object\r\n\t\t\tif (typeof entry === \"object\" && typeof entry.entryName !== \"undefined\" && typeof entry.header !== \"undefined\")\r\n\t\t\t\titem = _zip.getEntry(entry.entryName);\r\n\r\n\t\t\tif (item) {\r\n\t\t\t\treturn item;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * Extracts the given entry from the archive and returns the content as a Buffer object\r\n\t\t * @param entry ZipEntry object or String with the full path of the entry\r\n\t\t *\r\n\t\t * @return Buffer or Null in case of error\r\n\t\t */\r\n\t\treadFile: function (/**Object*/entry) {\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\treturn item && item.getData() || null;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Asynchronous readFile\r\n\t\t * @param entry ZipEntry object or String with the full path of the entry\r\n\t\t * @param callback\r\n\t\t *\r\n\t\t * @return Buffer or Null in case of error\r\n\t\t */\r\n\t\treadFileAsync: function (/**Object*/entry, /**Function*/callback) {\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (item) {\r\n\t\t\t\titem.getDataAsync(callback);\r\n\t\t\t} else {\r\n\t\t\t\tcallback(null, \"getEntry failed for:\" + entry)\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Extracts the given entry from the archive and returns the content as plain text in the given encoding\r\n\t\t * @param entry ZipEntry object or String with the full path of the entry\r\n\t\t * @param encoding Optional. If no encoding is specified utf8 is used\r\n\t\t *\r\n\t\t * @return String\r\n\t\t */\r\n\t\treadAsText: function (/**Object*/entry, /**String=*/encoding) {\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (item) {\r\n\t\t\t\tvar data = item.getData();\r\n\t\t\t\tif (data && data.length) {\r\n\t\t\t\t\treturn data.toString(encoding || \"utf8\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn \"\";\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Asynchronous readAsText\r\n\t\t * @param entry ZipEntry object or String with the full path of the entry\r\n\t\t * @param callback\r\n\t\t * @param encoding Optional. If no encoding is specified utf8 is used\r\n\t\t *\r\n\t\t * @return String\r\n\t\t */\r\n\t\treadAsTextAsync: function (/**Object*/entry, /**Function*/callback, /**String=*/encoding) {\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (item) {\r\n\t\t\t\titem.getDataAsync(function (data, err) {\r\n\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\tcallback(data, err);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (data && data.length) {\r\n\t\t\t\t\t\tcallback(data.toString(encoding || \"utf8\"));\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcallback(\"\");\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\tcallback(\"\");\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory\r\n\t\t *\r\n\t\t * @param entry\r\n\t\t */\r\n\t\tdeleteFile: function (/**Object*/entry) { // @TODO: test deleteFile\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (item) {\r\n\t\t\t\t_zip.deleteEntry(item.entryName);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds a comment to the zip. The zip must be rewritten after adding the comment.\r\n\t\t *\r\n\t\t * @param comment\r\n\t\t */\r\n\t\taddZipComment: function (/**String*/comment) { // @TODO: test addZipComment\r\n\t\t\t_zip.comment = comment;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the zip comment\r\n\t\t *\r\n\t\t * @return String\r\n\t\t */\r\n\t\tgetZipComment: function () {\r\n\t\t\treturn _zip.comment || '';\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment\r\n\t\t * The comment cannot exceed 65535 characters in length\r\n\t\t *\r\n\t\t * @param entry\r\n\t\t * @param comment\r\n\t\t */\r\n\t\taddZipEntryComment: function (/**Object*/entry, /**String*/comment) {\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (item) {\r\n\t\t\t\titem.comment = comment;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the comment of the specified entry\r\n\t\t *\r\n\t\t * @param entry\r\n\t\t * @return String\r\n\t\t */\r\n\t\tgetZipEntryComment: function (/**Object*/entry) {\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (item) {\r\n\t\t\t\treturn item.comment || '';\r\n\t\t\t}\r\n\t\t\treturn ''\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content\r\n\t\t *\r\n\t\t * @param entry\r\n\t\t * @param content\r\n\t\t */\r\n\t\tupdateFile: function (/**Object*/entry, /**Buffer*/content) {\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (item) {\r\n\t\t\t\titem.setData(content);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds a file from the disk to the archive\r\n\t\t *\r\n\t\t * @param localPath File to add to zip\r\n\t\t * @param zipPath Optional path inside the zip\r\n\t\t * @param zipName Optional name for the file\r\n\t\t */\r\n\t\taddLocalFile: function (/**String*/localPath, /**String=*/zipPath, /**String=*/zipName) {\r\n\t\t\tif (fs.existsSync(localPath)) {\r\n\t\t\t\tif (zipPath) {\r\n\t\t\t\t\tzipPath = zipPath.split(\"\\\\\").join(\"/\");\r\n\t\t\t\t\tif (zipPath.charAt(zipPath.length - 1) !== \"/\") {\r\n\t\t\t\t\t\tzipPath += \"/\";\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tzipPath = \"\";\r\n\t\t\t\t}\r\n\t\t\t\tvar p = localPath.split(\"\\\\\").join(\"/\").split(\"/\").pop();\r\n\r\n\t\t\t\tif (zipName) {\r\n\t\t\t\t\tthis.addFile(zipPath + zipName, fs.readFileSync(localPath), \"\", 0)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.addFile(zipPath + p, fs.readFileSync(localPath), \"\", 0)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthrow Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds a local directory and all its nested files and directories to the archive\r\n\t\t *\r\n\t\t * @param localPath\r\n\t\t * @param zipPath optional path inside zip\r\n\t\t * @param filter optional RegExp or Function if files match will\r\n\t\t *               be included.\r\n\t\t */\r\n\t\taddLocalFolder: function (/**String*/localPath, /**String=*/zipPath, /**=RegExp|Function*/filter) {\r\n\t\t\tif (filter === undefined) {\r\n\t\t\t\tfilter = function () {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t};\r\n\t\t\t} else if (filter instanceof RegExp) {\r\n\t\t\t\tfilter = function (filter) {\r\n\t\t\t\t\treturn function (filename) {\r\n\t\t\t\t\t\treturn filter.test(filename);\r\n\t\t\t\t\t}\r\n\t\t\t\t}(filter);\r\n\t\t\t}\r\n\r\n\t\t\tif (zipPath) {\r\n\t\t\t\tzipPath = zipPath.split(\"\\\\\").join(\"/\");\r\n\t\t\t\tif (zipPath.charAt(zipPath.length - 1) !== \"/\") {\r\n\t\t\t\t\tzipPath += \"/\";\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tzipPath = \"\";\r\n\t\t\t}\r\n\t\t\t// normalize the path first\r\n\t\t\tlocalPath = pth.normalize(localPath);\r\n\t\t\tlocalPath = localPath.split(\"\\\\\").join(\"/\"); //windows fix\r\n\t\t\tif (localPath.charAt(localPath.length - 1) !== \"/\")\r\n\t\t\t\tlocalPath += \"/\";\r\n\r\n\t\t\tif (fs.existsSync(localPath)) {\r\n\r\n\t\t\t\tvar items = Utils.findFiles(localPath),\r\n\t\t\t\t\tself = this;\r\n\r\n\t\t\t\tif (items.length) {\r\n\t\t\t\t\titems.forEach(function (path) {\r\n\t\t\t\t\t\tvar p = path.split(\"\\\\\").join(\"/\").replace(new RegExp(localPath.replace(/(\\(|\\))/g, '\\\\$1'), 'i'), \"\"); //windows fix\r\n\t\t\t\t\t\tif (filter(p)) {\r\n\t\t\t\t\t\t\tif (p.charAt(p.length - 1) !== \"/\") {\r\n\t\t\t\t\t\t\t\tself.addFile(zipPath + p, fs.readFileSync(path), \"\", 0)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tself.addFile(zipPath + p, Buffer.alloc(0), \"\", 0)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthrow Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Asynchronous addLocalFile\r\n\t\t * @param localPath\r\n\t\t * @param callback\r\n\t\t * @param zipPath optional path inside zip\r\n\t\t * @param filter optional RegExp or Function if files match will\r\n\t\t *               be included.\r\n\t\t */\r\n\t\taddLocalFolderAsync: function (/*String*/localPath, /*Function*/callback, /*String*/zipPath, /*RegExp|Function*/filter) {\r\n\t\t\tif (filter === undefined) {\r\n\t\t\t\tfilter = function () {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t};\r\n\t\t\t} else if (filter instanceof RegExp) {\r\n\t\t\t\tfilter = function (filter) {\r\n\t\t\t\t\treturn function (filename) {\r\n\t\t\t\t\t\treturn filter.test(filename);\r\n\t\t\t\t\t}\r\n\t\t\t\t}(filter);\r\n\t\t\t}\r\n\r\n\t\t\tif (zipPath) {\r\n\t\t\t\tzipPath = zipPath.split(\"\\\\\").join(\"/\");\r\n\t\t\t\tif (zipPath.charAt(zipPath.length - 1) !== \"/\") {\r\n\t\t\t\t\tzipPath += \"/\";\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tzipPath = \"\";\r\n\t\t\t}\r\n\t\t\t// normalize the path first\r\n\t\t\tlocalPath = pth.normalize(localPath);\r\n\t\t\tlocalPath = localPath.split(\"\\\\\").join(\"/\"); //windows fix\r\n\t\t\tif (localPath.charAt(localPath.length - 1) !== \"/\")\r\n\t\t\t\tlocalPath += \"/\";\r\n\r\n\t\t\tvar self = this;\r\n\t\t\tfs.open(localPath, 'r', function (err, fd) {\r\n\t\t\t\tif (err && err.code === 'ENOENT') {\r\n\t\t\t\t\tcallback(undefined, Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\r\n\t\t\t\t} else if (err) {\r\n\t\t\t\t\tcallback(undefined, err);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar items = Utils.findFiles(localPath);\r\n\t\t\t\t\tvar i = -1;\r\n\r\n\t\t\t\t\tvar next = function () {\r\n\t\t\t\t\t\ti += 1;\r\n\t\t\t\t\t\tif (i < items.length) {\r\n\t\t\t\t\t\t\tvar p = items[i].split(\"\\\\\").join(\"/\").replace(new RegExp(localPath.replace(/(\\(|\\))/g, '\\\\$1'), 'i'), \"\"); //windows fix\r\n\t\t\t\t\t\t\tp = p.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').replace(/[^\\x20-\\x7E]/g, '') // accent fix\r\n\t\t\t\t\t\t\tif (filter(p)) {\r\n\t\t\t\t\t\t\t\tif (p.charAt(p.length - 1) !== \"/\") {\r\n\t\t\t\t\t\t\t\t\tfs.readFile(items[i], function (err, data) {\r\n\t\t\t\t\t\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\t\t\t\t\t\tcallback(undefined, err);\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\tself.addFile(zipPath + p, data, '', 0);\r\n\t\t\t\t\t\t\t\t\t\t\tnext();\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tself.addFile(zipPath + p, Buffer.alloc(0), \"\", 0);\r\n\t\t\t\t\t\t\t\t\tnext();\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tnext();\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tcallback(true, undefined);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tnext();\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Allows you to create a entry (file or directory) in the zip file.\r\n\t\t * If you want to create a directory the entryName must end in / and a null buffer should be provided.\r\n\t\t * Comment and attributes are optional\r\n\t\t *\r\n\t\t * @param entryName\r\n\t\t * @param content\r\n\t\t * @param comment\r\n\t\t * @param attr\r\n\t\t */\r\n\t\taddFile: function (/**String*/entryName, /**Buffer*/content, /**String*/comment, /**Number*/attr) {\r\n\t\t\tvar entry = new ZipEntry();\r\n\t\t\tentry.entryName = entryName;\r\n\t\t\tentry.comment = comment || \"\";\r\n\r\n\t\t\tif (!attr) {\r\n\t\t\t\tif (entry.isDirectory) {\r\n\t\t\t\t\tattr = (0o40755 << 16) | 0x10; // (permissions drwxr-xr-x) + (MS-DOS directory flag)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tattr = 0o644 << 16; // permissions -r-wr--r--\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tentry.attr = attr;\r\n\r\n\t\t\tentry.setData(content);\r\n\t\t\t_zip.setEntry(entry);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns an array of ZipEntry objects representing the files and folders inside the archive\r\n\t\t *\r\n\t\t * @return Array\r\n\t\t */\r\n\t\tgetEntries: function () {\r\n\t\t\tif (_zip) {\r\n\t\t\t\treturn _zip.entries;\r\n\t\t\t} else {\r\n\t\t\t\treturn [];\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns a ZipEntry object representing the file or folder specified by ``name``.\r\n\t\t *\r\n\t\t * @param name\r\n\t\t * @return ZipEntry\r\n\t\t */\r\n\t\tgetEntry: function (/**String*/name) {\r\n\t\t\treturn getEntry(name);\r\n\t\t},\r\n\r\n\t\tgetEntryCount: function() {\r\n\t\t\treturn _zip.getEntryCount();\r\n\t\t},\r\n\r\n\t\tforEach: function(callback) {\r\n\t\t\treturn _zip.forEach(callback);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Extracts the given entry to the given targetPath\r\n\t\t * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted\r\n\t\t *\r\n\t\t * @param entry ZipEntry object or String with the full path of the entry\r\n\t\t * @param targetPath Target folder where to write the file\r\n\t\t * @param maintainEntryPath If maintainEntryPath is true and the entry is inside a folder, the entry folder\r\n\t\t *                          will be created in targetPath as well. Default is TRUE\r\n\t\t * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\r\n\t\t *                  Default is FALSE\r\n\t\t *\r\n\t\t * @return Boolean\r\n\t\t */\r\n\t\textractEntryTo: function (/**Object*/entry, /**String*/targetPath, /**Boolean*/maintainEntryPath, /**Boolean*/overwrite) {\r\n\t\t\toverwrite = overwrite || false;\r\n\t\t\tmaintainEntryPath = typeof maintainEntryPath === \"undefined\" ? true : maintainEntryPath;\r\n\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (!item) {\r\n\t\t\t\tthrow Utils.Errors.NO_ENTRY;\r\n\t\t\t}\r\n\r\n\t\t\tvar entryName = item.entryName;\r\n\r\n\t\t\tvar target = sanitize(targetPath, maintainEntryPath ? entryName : pth.basename(entryName));\r\n\r\n\t\t\tif (item.isDirectory) {\r\n\t\t\t\ttarget = pth.resolve(target, \"..\");\r\n\t\t\t\tvar children = _zip.getEntryChildren(item);\r\n\t\t\t\tchildren.forEach(function (child) {\r\n\t\t\t\t\tif (child.isDirectory) return;\r\n\t\t\t\t\tvar content = child.getData();\r\n\t\t\t\t\tif (!content) {\r\n\t\t\t\t\t\tthrow Utils.Errors.CANT_EXTRACT_FILE;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar childName = sanitize(targetPath, maintainEntryPath ? child.entryName : pth.basename(child.entryName));\r\n\r\n\t\t\t\t\tUtils.writeFileTo(childName, content, overwrite);\r\n\t\t\t\t});\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\tvar content = item.getData();\r\n\t\t\tif (!content) throw Utils.Errors.CANT_EXTRACT_FILE;\r\n\r\n\t\t\tif (fs.existsSync(target) && !overwrite) {\r\n\t\t\t\tthrow Utils.Errors.CANT_OVERRIDE;\r\n\t\t\t}\r\n\t\t\tUtils.writeFileTo(target, content, overwrite);\r\n\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Test the archive\r\n\t\t *\r\n\t\t */\r\n\t\ttest: function () {\r\n\t\t\tif (!_zip) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tfor (var entry in _zip.entries) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (entry.isDirectory) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar content = _zip.entries[entry].getData();\r\n\t\t\t\t\tif (!content) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (err) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Extracts the entire archive to the given location\r\n\t\t *\r\n\t\t * @param targetPath Target location\r\n\t\t * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\r\n\t\t *                  Default is FALSE\r\n\t\t */\r\n\t\textractAllTo: function (/**String*/targetPath, /**Boolean*/overwrite) {\r\n\t\t\toverwrite = overwrite || false;\r\n\t\t\tif (!_zip) {\r\n\t\t\t\tthrow Utils.Errors.NO_ZIP;\r\n\t\t\t}\r\n\t\t\t_zip.entries.forEach(function (entry) {\r\n\t\t\t\tvar entryName = sanitize(targetPath, entry.entryName.toString());\r\n\t\t\t\tif (entry.isDirectory) {\r\n\t\t\t\t\tUtils.makeDir(entryName);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tvar content = entry.getData();\r\n\t\t\t\tif (!content) {\r\n\t\t\t\t\tthrow Utils.Errors.CANT_EXTRACT_FILE;\r\n\t\t\t\t}\r\n\t\t\t\tUtils.writeFileTo(entryName, content, overwrite);\r\n\t\t\t\ttry {\r\n\t\t\t\t\tfs.utimesSync(entryName, entry.header.time, entry.header.time)\r\n\t\t\t\t} catch (err) {\r\n\t\t\t\t\tthrow Utils.Errors.CANT_EXTRACT_FILE;\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Asynchronous extractAllTo\r\n\t\t *\r\n\t\t * @param targetPath Target location\r\n\t\t * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\r\n\t\t *                  Default is FALSE\r\n\t\t * @param callback\r\n\t\t */\r\n\t\textractAllToAsync: function (/**String*/targetPath, /**Boolean*/overwrite, /**Function*/callback) {\r\n\t\t\tif (!callback) {\r\n\t\t\t\tcallback = function() {}\r\n\t\t\t}\r\n\t\t\toverwrite = overwrite || false;\r\n\t\t\tif (!_zip) {\r\n\t\t\t\tcallback(new Error(Utils.Errors.NO_ZIP));\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar entries = _zip.entries;\r\n\t\t\tvar i = entries.length;\r\n\t\t\tentries.forEach(function (entry) {\r\n\t\t\t\tif (i <= 0) return; // Had an error already\r\n\r\n\t\t\t\tvar entryName = pth.normalize(entry.entryName.toString());\r\n\r\n\t\t\t\tif (entry.isDirectory) {\r\n\t\t\t\t\tUtils.makeDir(sanitize(targetPath, entryName));\r\n\t\t\t\t\tif (--i === 0)\r\n\t\t\t\t\t\tcallback(undefined);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tentry.getDataAsync(function (content, err) {\r\n\t\t\t\t\tif (i <= 0) return;\r\n\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\tcallback(new Error(err));\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!content) {\r\n\t\t\t\t\t\ti = 0;\r\n\t\t\t\t\t\tcallback(new Error(Utils.Errors.CANT_EXTRACT_FILE));\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tUtils.writeFileToAsync(sanitize(targetPath, entryName), content, overwrite, function (succ) {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tfs.utimesSync(pth.resolve(targetPath, entryName), entry.header.time, entry.header.time);\r\n\t\t\t\t\t\t} catch (err) {\r\n\t\t\t\t\t\t\tcallback(new Error('Unable to set utimes'));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (i <= 0) return;\r\n\t\t\t\t\t\tif (!succ) {\r\n\t\t\t\t\t\t\ti = 0;\r\n\t\t\t\t\t\t\tcallback(new Error('Unable to write'));\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (--i === 0)\r\n\t\t\t\t\t\t\tcallback(undefined);\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip\r\n\t\t *\r\n\t\t * @param targetFileName\r\n\t\t * @param callback\r\n\t\t */\r\n\t\twriteZip: function (/**String*/targetFileName, /**Function*/callback) {\r\n\t\t\tif (arguments.length === 1) {\r\n\t\t\t\tif (typeof targetFileName === \"function\") {\r\n\t\t\t\t\tcallback = targetFileName;\r\n\t\t\t\t\ttargetFileName = \"\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (!targetFileName && _filename) {\r\n\t\t\t\ttargetFileName = _filename;\r\n\t\t\t}\r\n\t\t\tif (!targetFileName) return;\r\n\r\n\t\t\tvar zipData = _zip.compressToBuffer();\r\n\t\t\tif (zipData) {\r\n\t\t\t\tvar ok = Utils.writeFileTo(targetFileName, zipData, true);\r\n\t\t\t\tif (typeof callback === 'function') callback(!ok ? new Error(\"failed\") : null, \"\");\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the content of the entire zip file as a Buffer object\r\n\t\t *\r\n\t\t * @return Buffer\r\n\t\t */\r\n\t\ttoBuffer: function (/**Function=*/onSuccess, /**Function=*/onFail, /**Function=*/onItemStart, /**Function=*/onItemEnd) {\r\n\t\t\tthis.valueOf = 2;\r\n\t\t\tif (typeof onSuccess === \"function\") {\r\n\t\t\t\t_zip.toAsyncBuffer(onSuccess, onFail, onItemStart, onItemEnd);\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\treturn _zip.compressToBuffer()\r\n\t\t}\r\n\t}\r\n};\r\n","var Utils = require(\"../util\"),\r\n    Constants = Utils.Constants;\r\n\r\n/* The central directory file header */\r\nmodule.exports = function () {\r\n    var _verMade = 0x0A,\r\n        _version = 0x0A,\r\n        _flags = 0,\r\n        _method = 0,\r\n        _time = 0,\r\n        _crc = 0,\r\n        _compressedSize = 0,\r\n        _size = 0,\r\n        _fnameLen = 0,\r\n        _extraLen = 0,\r\n\r\n        _comLen = 0,\r\n        _diskStart = 0,\r\n        _inattr = 0,\r\n        _attr = 0,\r\n        _offset = 0;\r\n\r\n    var _dataHeader = {};\r\n\r\n    function setTime(val) {\r\n        val = new Date(val);\r\n        _time = (val.getFullYear() - 1980 & 0x7f) << 25  // b09-16 years from 1980\r\n            | (val.getMonth() + 1) << 21                 // b05-08 month\r\n            | val.getDate() << 16                        // b00-04 hour\r\n\r\n            // 2 bytes time\r\n            | val.getHours() << 11    // b11-15 hour\r\n            | val.getMinutes() << 5   // b05-10 minute\r\n            | val.getSeconds() >> 1;  // b00-04 seconds divided by 2\r\n    }\r\n\r\n    setTime(+new Date());\r\n\r\n    return {\r\n        get made () { return _verMade; },\r\n        set made (val) { _verMade = val; },\r\n\r\n        get version () { return _version; },\r\n        set version (val) { _version = val },\r\n\r\n        get flags () { return _flags },\r\n        set flags (val) { _flags = val; },\r\n\r\n        get method () { return _method; },\r\n        set method (val) { _method = val; },\r\n\r\n        get time () { return new Date(\r\n            ((_time >> 25) & 0x7f) + 1980,\r\n            ((_time >> 21) & 0x0f) - 1,\r\n            (_time >> 16) & 0x1f,\r\n            (_time >> 11) & 0x1f,\r\n            (_time >> 5) & 0x3f,\r\n            (_time & 0x1f) << 1\r\n        );\r\n        },\r\n        set time (val) {\r\n            setTime(val);\r\n        },\r\n\r\n        get crc () { return _crc; },\r\n        set crc (val) { _crc = val; },\r\n\r\n        get compressedSize () { return _compressedSize; },\r\n        set compressedSize (val) { _compressedSize = val; },\r\n\r\n        get size () { return _size; },\r\n        set size (val) { _size = val; },\r\n\r\n        get fileNameLength () { return _fnameLen; },\r\n        set fileNameLength (val) { _fnameLen = val; },\r\n\r\n        get extraLength () { return _extraLen },\r\n        set extraLength (val) { _extraLen = val; },\r\n\r\n        get commentLength () { return _comLen },\r\n        set commentLength (val) { _comLen = val },\r\n\r\n        get diskNumStart () { return _diskStart },\r\n        set diskNumStart (val) { _diskStart = val },\r\n\r\n        get inAttr () { return _inattr },\r\n        set inAttr (val) { _inattr = val },\r\n\r\n        get attr () { return _attr },\r\n        set attr (val) { _attr = val },\r\n\r\n        get offset () { return _offset },\r\n        set offset (val) { _offset = val },\r\n\r\n        get encripted () { return (_flags & 1) === 1 },\r\n\r\n        get entryHeaderSize () {\r\n            return Constants.CENHDR + _fnameLen + _extraLen + _comLen;\r\n        },\r\n\r\n        get realDataOffset () {\r\n            return _offset + Constants.LOCHDR + _dataHeader.fnameLen + _dataHeader.extraLen;\r\n        },\r\n\r\n        get dataHeader () {\r\n            return _dataHeader;\r\n        },\r\n\r\n        loadDataHeaderFromBinary : function(/*Buffer*/input) {\r\n            var data = input.slice(_offset, _offset + Constants.LOCHDR);\r\n            // 30 bytes and should start with \"PK\\003\\004\"\r\n            if (data.readUInt32LE(0) !== Constants.LOCSIG) {\r\n                throw Utils.Errors.INVALID_LOC;\r\n            }\r\n            _dataHeader = {\r\n                // version needed to extract\r\n                version : data.readUInt16LE(Constants.LOCVER),\r\n                // general purpose bit flag\r\n                flags : data.readUInt16LE(Constants.LOCFLG),\r\n                // compression method\r\n                method : data.readUInt16LE(Constants.LOCHOW),\r\n                // modification time (2 bytes time, 2 bytes date)\r\n                time : data.readUInt32LE(Constants.LOCTIM),\r\n                // uncompressed file crc-32 value\r\n                crc : data.readUInt32LE(Constants.LOCCRC),\r\n                // compressed size\r\n                compressedSize : data.readUInt32LE(Constants.LOCSIZ),\r\n                // uncompressed size\r\n                size : data.readUInt32LE(Constants.LOCLEN),\r\n                // filename length\r\n                fnameLen : data.readUInt16LE(Constants.LOCNAM),\r\n                // extra field length\r\n                extraLen : data.readUInt16LE(Constants.LOCEXT)\r\n            }\r\n        },\r\n\r\n        loadFromBinary : function(/*Buffer*/data) {\r\n            // data should be 46 bytes and start with \"PK 01 02\"\r\n            if (data.length !== Constants.CENHDR || data.readUInt32LE(0) !== Constants.CENSIG) {\r\n                throw Utils.Errors.INVALID_CEN;\r\n            }\r\n            // version made by\r\n            _verMade = data.readUInt16LE(Constants.CENVEM);\r\n            // version needed to extract\r\n            _version = data.readUInt16LE(Constants.CENVER);\r\n            // encrypt, decrypt flags\r\n            _flags = data.readUInt16LE(Constants.CENFLG);\r\n            // compression method\r\n            _method = data.readUInt16LE(Constants.CENHOW);\r\n            // modification time (2 bytes time, 2 bytes date)\r\n            _time = data.readUInt32LE(Constants.CENTIM);\r\n            // uncompressed file crc-32 value\r\n            _crc = data.readUInt32LE(Constants.CENCRC);\r\n            // compressed size\r\n            _compressedSize = data.readUInt32LE(Constants.CENSIZ);\r\n            // uncompressed size\r\n            _size = data.readUInt32LE(Constants.CENLEN);\r\n            // filename length\r\n            _fnameLen = data.readUInt16LE(Constants.CENNAM);\r\n            // extra field length\r\n            _extraLen = data.readUInt16LE(Constants.CENEXT);\r\n            // file comment length\r\n            _comLen = data.readUInt16LE(Constants.CENCOM);\r\n            // volume number start\r\n            _diskStart = data.readUInt16LE(Constants.CENDSK);\r\n            // internal file attributes\r\n            _inattr = data.readUInt16LE(Constants.CENATT);\r\n            // external file attributes\r\n            _attr = data.readUInt32LE(Constants.CENATX);\r\n            // LOC header offset\r\n            _offset = data.readUInt32LE(Constants.CENOFF);\r\n        },\r\n\r\n        dataHeaderToBinary : function() {\r\n            // LOC header size (30 bytes)\r\n            var data = Buffer.alloc(Constants.LOCHDR);\r\n            // \"PK\\003\\004\"\r\n            data.writeUInt32LE(Constants.LOCSIG, 0);\r\n            // version needed to extract\r\n            data.writeUInt16LE(_version, Constants.LOCVER);\r\n            // general purpose bit flag\r\n            data.writeUInt16LE(_flags, Constants.LOCFLG);\r\n            // compression method\r\n            data.writeUInt16LE(_method, Constants.LOCHOW);\r\n            // modification time (2 bytes time, 2 bytes date)\r\n            data.writeUInt32LE(_time, Constants.LOCTIM);\r\n            // uncompressed file crc-32 value\r\n            data.writeUInt32LE(_crc, Constants.LOCCRC);\r\n            // compressed size\r\n            data.writeUInt32LE(_compressedSize, Constants.LOCSIZ);\r\n            // uncompressed size\r\n            data.writeUInt32LE(_size, Constants.LOCLEN);\r\n            // filename length\r\n            data.writeUInt16LE(_fnameLen, Constants.LOCNAM);\r\n            // extra field length\r\n            data.writeUInt16LE(_extraLen, Constants.LOCEXT);\r\n            return data;\r\n        },\r\n\r\n        entryHeaderToBinary : function() {\r\n            // CEN header size (46 bytes)\r\n            var data = Buffer.alloc(Constants.CENHDR + _fnameLen + _extraLen + _comLen);\r\n            // \"PK\\001\\002\"\r\n            data.writeUInt32LE(Constants.CENSIG, 0);\r\n            // version made by\r\n            data.writeUInt16LE(_verMade, Constants.CENVEM);\r\n            // version needed to extract\r\n            data.writeUInt16LE(_version, Constants.CENVER);\r\n            // encrypt, decrypt flags\r\n            data.writeUInt16LE(_flags, Constants.CENFLG);\r\n            // compression method\r\n            data.writeUInt16LE(_method, Constants.CENHOW);\r\n            // modification time (2 bytes time, 2 bytes date)\r\n            data.writeUInt32LE(_time, Constants.CENTIM);\r\n            // uncompressed file crc-32 value\r\n            data.writeUInt32LE(_crc, Constants.CENCRC);\r\n            // compressed size\r\n            data.writeUInt32LE(_compressedSize, Constants.CENSIZ);\r\n            // uncompressed size\r\n            data.writeUInt32LE(_size, Constants.CENLEN);\r\n            // filename length\r\n            data.writeUInt16LE(_fnameLen, Constants.CENNAM);\r\n            // extra field length\r\n            data.writeUInt16LE(_extraLen, Constants.CENEXT);\r\n            // file comment length\r\n            data.writeUInt16LE(_comLen, Constants.CENCOM);\r\n            // volume number start\r\n            data.writeUInt16LE(_diskStart, Constants.CENDSK);\r\n            // internal file attributes\r\n            data.writeUInt16LE(_inattr, Constants.CENATT);\r\n            // external file attributes\r\n            data.writeUInt32LE(_attr, Constants.CENATX);\r\n            // LOC header offset\r\n            data.writeUInt32LE(_offset, Constants.CENOFF);\r\n            // fill all with\r\n            data.fill(0x00, Constants.CENHDR);\r\n            return data;\r\n        },\r\n\r\n        toString : function() {\r\n            return '{\\n' +\r\n                '\\t\"made\" : ' + _verMade + \",\\n\" +\r\n                '\\t\"version\" : ' + _version + \",\\n\" +\r\n                '\\t\"flags\" : ' + _flags + \",\\n\" +\r\n                '\\t\"method\" : ' + Utils.methodToString(_method) + \",\\n\" +\r\n                '\\t\"time\" : ' + this.time + \",\\n\" +\r\n                '\\t\"crc\" : 0x' + _crc.toString(16).toUpperCase() + \",\\n\" +\r\n                '\\t\"compressedSize\" : ' + _compressedSize + \" bytes,\\n\" +\r\n                '\\t\"size\" : ' + _size + \" bytes,\\n\" +\r\n                '\\t\"fileNameLength\" : ' + _fnameLen + \",\\n\" +\r\n                '\\t\"extraLength\" : ' + _extraLen + \" bytes,\\n\" +\r\n                '\\t\"commentLength\" : ' + _comLen + \" bytes,\\n\" +\r\n                '\\t\"diskNumStart\" : ' + _diskStart + \",\\n\" +\r\n                '\\t\"inAttr\" : ' + _inattr + \",\\n\" +\r\n                '\\t\"attr\" : ' + _attr + \",\\n\" +\r\n                '\\t\"offset\" : ' + _offset + \",\\n\" +\r\n                '\\t\"entryHeaderSize\" : ' + (Constants.CENHDR + _fnameLen + _extraLen + _comLen) + \" bytes\\n\" +\r\n                '}';\r\n        }\r\n    }\r\n};\r\n","exports.EntryHeader = require(\"./entryHeader\");\r\nexports.MainHeader = require(\"./mainHeader\");\r\n","var Utils = require(\"../util\"),\r\n    Constants = Utils.Constants;\r\n\r\n/* The entries in the end of central directory */\r\nmodule.exports = function () {\r\n    var _volumeEntries = 0,\r\n        _totalEntries = 0,\r\n        _size = 0,\r\n        _offset = 0,\r\n        _commentLength = 0;\r\n\r\n    return {\r\n        get diskEntries () { return _volumeEntries },\r\n        set diskEntries (/*Number*/val) { _volumeEntries = _totalEntries = val; },\r\n\r\n        get totalEntries () { return _totalEntries },\r\n        set totalEntries (/*Number*/val) { _totalEntries = _volumeEntries = val; },\r\n\r\n        get size () { return _size },\r\n        set size (/*Number*/val) { _size = val; },\r\n\r\n        get offset () { return _offset },\r\n        set offset (/*Number*/val) { _offset = val; },\r\n\r\n        get commentLength () { return _commentLength },\r\n        set commentLength (/*Number*/val) { _commentLength = val; },\r\n\r\n        get mainHeaderSize () {\r\n            return Constants.ENDHDR + _commentLength;\r\n        },\r\n\r\n        loadFromBinary : function(/*Buffer*/data) {\r\n            // data should be 22 bytes and start with \"PK 05 06\"\r\n            // or be 56+ bytes and start with \"PK 06 06\" for Zip64\r\n            if ((data.length !== Constants.ENDHDR || data.readUInt32LE(0) !== Constants.ENDSIG) &&\r\n                (data.length < Constants.ZIP64HDR || data.readUInt32LE(0) !== Constants.ZIP64SIG)) {\r\n\r\n                throw Utils.Errors.INVALID_END;\r\n            }\r\n\r\n            if (data.readUInt32LE(0) === Constants.ENDSIG) {\r\n                // number of entries on this volume\r\n                _volumeEntries = data.readUInt16LE(Constants.ENDSUB);\r\n                // total number of entries\r\n                _totalEntries = data.readUInt16LE(Constants.ENDTOT);\r\n                // central directory size in bytes\r\n                _size = data.readUInt32LE(Constants.ENDSIZ);\r\n                // offset of first CEN header\r\n                _offset = data.readUInt32LE(Constants.ENDOFF);\r\n                // zip file comment length\r\n                _commentLength = data.readUInt16LE(Constants.ENDCOM);\r\n            } else {\r\n                // number of entries on this volume\r\n                _volumeEntries = Utils.readBigUInt64LE(data, Constants.ZIP64SUB);\r\n                // total number of entries\r\n                _totalEntries = Utils.readBigUInt64LE(data, Constants.ZIP64TOT);\r\n                // central directory size in bytes\r\n                _size = Utils.readBigUInt64LE(data, Constants.ZIP64SIZ);\r\n                // offset of first CEN header\r\n                _offset = Utils.readBigUInt64LE(data, Constants.ZIP64OFF);\r\n\r\n                _commentLength = 0;\r\n            }\r\n\r\n        },\r\n\r\n        toBinary : function() {\r\n           var b = Buffer.alloc(Constants.ENDHDR + _commentLength);\r\n            // \"PK 05 06\" signature\r\n            b.writeUInt32LE(Constants.ENDSIG, 0);\r\n            b.writeUInt32LE(0, 4);\r\n            // number of entries on this volume\r\n            b.writeUInt16LE(_volumeEntries, Constants.ENDSUB);\r\n            // total number of entries\r\n            b.writeUInt16LE(_totalEntries, Constants.ENDTOT);\r\n            // central directory size in bytes\r\n            b.writeUInt32LE(_size, Constants.ENDSIZ);\r\n            // offset of first CEN header\r\n            b.writeUInt32LE(_offset, Constants.ENDOFF);\r\n            // zip file comment length\r\n            b.writeUInt16LE(_commentLength, Constants.ENDCOM);\r\n            // fill comment memory with spaces so no garbage is left there\r\n            b.fill(\" \", Constants.ENDHDR);\r\n\r\n            return b;\r\n        },\r\n\r\n        toString : function() {\r\n            return '{\\n' +\r\n                '\\t\"diskEntries\" : ' + _volumeEntries + \",\\n\" +\r\n                '\\t\"totalEntries\" : ' + _totalEntries + \",\\n\" +\r\n                '\\t\"size\" : ' + _size + \" bytes,\\n\" +\r\n                '\\t\"offset\" : 0x' + _offset.toString(16).toUpperCase() + \",\\n\" +\r\n                '\\t\"commentLength\" : 0x' + _commentLength + \"\\n\" +\r\n            '}';\r\n        }\r\n    }\r\n};","module.exports = function (/*Buffer*/inbuf) {\r\n\r\n  var zlib = require(\"zlib\");\r\n  \r\n  var opts = {chunkSize: (parseInt(inbuf.length / 1024) + 1) * 1024};\r\n  \r\n  return {\r\n    deflate: function () {\r\n      return zlib.deflateRawSync(inbuf, opts);\r\n    },\r\n\r\n    deflateAsync: function (/*Function*/callback) {\r\n      var tmp = zlib.createDeflateRaw(opts), parts = [], total = 0;\r\n      tmp.on('data', function (data) {\r\n        parts.push(data);\r\n        total += data.length;\r\n      });\r\n      tmp.on('end', function () {\r\n        var buf = Buffer.alloc(total), written = 0;\r\n        buf.fill(0);\r\n        for (var i = 0; i < parts.length; i++) {\r\n          var part = parts[i];\r\n          part.copy(buf, written);\r\n          written += part.length;\r\n        }\r\n        callback && callback(buf);\r\n      });\r\n      tmp.end(inbuf);\r\n    }\r\n  }\r\n};\r\n","exports.Deflater = require(\"./deflater\");\r\nexports.Inflater = require(\"./inflater\");","module.exports = function (/*Buffer*/inbuf) {\r\n\r\n  var zlib = require(\"zlib\");\r\n\r\n  return {\r\n    inflate: function () {\r\n      return zlib.inflateRawSync(inbuf);\r\n    },\r\n\r\n    inflateAsync: function (/*Function*/callback) {\r\n      var tmp = zlib.createInflateRaw(), parts = [], total = 0;\r\n      tmp.on('data', function (data) {\r\n        parts.push(data);\r\n        total += data.length;\r\n      });\r\n      tmp.on('end', function () {\r\n        var buf = Buffer.alloc(total), written = 0;\r\n        buf.fill(0);\r\n        for (var i = 0; i < parts.length; i++) {\r\n          var part = parts[i];\r\n          part.copy(buf, written);\r\n          written += part.length;\r\n        }\r\n        callback && callback(buf);\r\n      });\r\n      tmp.end(inbuf);\r\n    }\r\n  }\r\n};\r\n","module.exports = {\r\n    /* The local file header */\r\n    LOCHDR           : 30, // LOC header size\r\n    LOCSIG           : 0x04034b50, // \"PK\\003\\004\"\r\n    LOCVER           : 4,\t// version needed to extract\r\n    LOCFLG           : 6, // general purpose bit flag\r\n    LOCHOW           : 8, // compression method\r\n    LOCTIM           : 10, // modification time (2 bytes time, 2 bytes date)\r\n    LOCCRC           : 14, // uncompressed file crc-32 value\r\n    LOCSIZ           : 18, // compressed size\r\n    LOCLEN           : 22, // uncompressed size\r\n    LOCNAM           : 26, // filename length\r\n    LOCEXT           : 28, // extra field length\r\n\r\n    /* The Data descriptor */\r\n    EXTSIG           : 0x08074b50, // \"PK\\007\\008\"\r\n    EXTHDR           : 16, // EXT header size\r\n    EXTCRC           : 4, // uncompressed file crc-32 value\r\n    EXTSIZ           : 8, // compressed size\r\n    EXTLEN           : 12, // uncompressed size\r\n\r\n    /* The central directory file header */\r\n    CENHDR           : 46, // CEN header size\r\n    CENSIG           : 0x02014b50, // \"PK\\001\\002\"\r\n    CENVEM           : 4, // version made by\r\n    CENVER           : 6, // version needed to extract\r\n    CENFLG           : 8, // encrypt, decrypt flags\r\n    CENHOW           : 10, // compression method\r\n    CENTIM           : 12, // modification time (2 bytes time, 2 bytes date)\r\n    CENCRC           : 16, // uncompressed file crc-32 value\r\n    CENSIZ           : 20, // compressed size\r\n    CENLEN           : 24, // uncompressed size\r\n    CENNAM           : 28, // filename length\r\n    CENEXT           : 30, // extra field length\r\n    CENCOM           : 32, // file comment length\r\n    CENDSK           : 34, // volume number start\r\n    CENATT           : 36, // internal file attributes\r\n    CENATX           : 38, // external file attributes (host system dependent)\r\n    CENOFF           : 42, // LOC header offset\r\n\r\n    /* The entries in the end of central directory */\r\n    ENDHDR           : 22, // END header size\r\n    ENDSIG           : 0x06054b50, // \"PK\\005\\006\"\r\n    ENDSUB           : 8, // number of entries on this disk\r\n    ENDTOT           : 10, // total number of entries\r\n    ENDSIZ           : 12, // central directory size in bytes\r\n    ENDOFF           : 16, // offset of first CEN header\r\n    ENDCOM           : 20, // zip file comment length\r\n\r\n    END64HDR         : 20, // zip64 END header size\r\n    END64SIG         : 0x07064b50, // zip64 Locator signature, \"PK\\006\\007\"\r\n    END64START       : 4, // number of the disk with the start of the zip64\r\n    END64OFF         : 8, // relative offset of the zip64 end of central directory\r\n    END64NUMDISKS    : 16, // total number of disks\r\n\r\n    ZIP64SIG         : 0x06064b50, // zip64 signature, \"PK\\006\\006\"\r\n    ZIP64HDR         : 56, // zip64 record minimum size\r\n    ZIP64LEAD        : 12, // leading bytes at the start of the record, not counted by the value stored in ZIP64SIZE\r\n    ZIP64SIZE        : 4, // zip64 size of the central directory record\r\n    ZIP64VEM         : 12, // zip64 version made by\r\n    ZIP64VER         : 14, // zip64 version needed to extract\r\n    ZIP64DSK         : 16, // zip64 number of this disk\r\n    ZIP64DSKDIR      : 20, // number of the disk with the start of the record directory\r\n    ZIP64SUB         : 24, // number of entries on this disk\r\n    ZIP64TOT         : 32, // total number of entries\r\n    ZIP64SIZB        : 40, // zip64 central directory size in bytes\r\n    ZIP64OFF         : 48, // offset of start of central directory with respect to the starting disk number\r\n    ZIP64EXTRA       : 56, // extensible data sector\r\n\r\n    /* Compression methods */\r\n    STORED           : 0, // no compression\r\n    SHRUNK           : 1, // shrunk\r\n    REDUCED1         : 2, // reduced with compression factor 1\r\n    REDUCED2         : 3, // reduced with compression factor 2\r\n    REDUCED3         : 4, // reduced with compression factor 3\r\n    REDUCED4         : 5, // reduced with compression factor 4\r\n    IMPLODED         : 6, // imploded\r\n    // 7 reserved\r\n    DEFLATED         : 8, // deflated\r\n    ENHANCED_DEFLATED: 9, // enhanced deflated\r\n    PKWARE           : 10,// PKWare DCL imploded\r\n    // 11 reserved\r\n    BZIP2            : 12, //  compressed using BZIP2\r\n    // 13 reserved\r\n    LZMA             : 14, // LZMA\r\n    // 15-17 reserved\r\n    IBM_TERSE        : 18, // compressed using IBM TERSE\r\n    IBM_LZ77         : 19, //IBM LZ77 z\r\n\r\n    /* General purpose bit flag */\r\n    FLG_ENC          : 0,  // encripted file\r\n    FLG_COMP1        : 1,  // compression option\r\n    FLG_COMP2        : 2,  // compression option\r\n    FLG_DESC         : 4,  // data descriptor\r\n    FLG_ENH          : 8,  // enhanced deflation\r\n    FLG_STR          : 16, // strong encryption\r\n    FLG_LNG          : 1024, // language encoding\r\n    FLG_MSK          : 4096, // mask header values\r\n\r\n    /* Load type */\r\n    FILE             : 0,\r\n    BUFFER           : 1,\r\n    NONE             : 2,\r\n\r\n    /* 4.5 Extensible data fields */\r\n    EF_ID            : 0,\r\n    EF_SIZE          : 2,\r\n\r\n    /* Header IDs */\r\n    ID_ZIP64         : 0x0001,\r\n    ID_AVINFO        : 0x0007,\r\n    ID_PFS           : 0x0008,\r\n    ID_OS2           : 0x0009,\r\n    ID_NTFS          : 0x000a,\r\n    ID_OPENVMS       : 0x000c,\r\n    ID_UNIX          : 0x000d,\r\n    ID_FORK          : 0x000e,\r\n    ID_PATCH         : 0x000f,\r\n    ID_X509_PKCS7    : 0x0014,\r\n    ID_X509_CERTID_F : 0x0015,\r\n    ID_X509_CERTID_C : 0x0016,\r\n    ID_STRONGENC     : 0x0017,\r\n    ID_RECORD_MGT    : 0x0018,\r\n    ID_X509_PKCS7_RL : 0x0019,\r\n    ID_IBM1          : 0x0065,\r\n    ID_IBM2          : 0x0066,\r\n    ID_POSZIP        : 0x4690,\r\n\r\n    EF_ZIP64_OR_32   : 0xffffffff,\r\n    EF_ZIP64_OR_16   : 0xffff,\r\n    EF_ZIP64_SUNCOMP : 0,\r\n    EF_ZIP64_SCOMP   : 8,\r\n    EF_ZIP64_RHO     : 16,\r\n    EF_ZIP64_DSN     : 24\r\n};\r\n","module.exports = {\r\n    /* Header error messages */\r\n    \"INVALID_LOC\" : \"Invalid LOC header (bad signature)\",\r\n    \"INVALID_CEN\" : \"Invalid CEN header (bad signature)\",\r\n    \"INVALID_END\" : \"Invalid END header (bad signature)\",\r\n\r\n    /* ZipEntry error messages*/\r\n    \"NO_DATA\" : \"Nothing to decompress\",\r\n    \"BAD_CRC\" : \"CRC32 checksum failed\",\r\n    \"FILE_IN_THE_WAY\" : \"There is a file in the way: %s\",\r\n    \"UNKNOWN_METHOD\" : \"Invalid/unsupported compression method\",\r\n\r\n    /* Inflater error messages */\r\n    \"AVAIL_DATA\" : \"inflate::Available inflate data did not terminate\",\r\n    \"INVALID_DISTANCE\" : \"inflate::Invalid literal/length or distance code in fixed or dynamic block\",\r\n    \"TO_MANY_CODES\" : \"inflate::Dynamic block code description: too many length or distance codes\",\r\n    \"INVALID_REPEAT_LEN\" : \"inflate::Dynamic block code description: repeat more than specified lengths\",\r\n    \"INVALID_REPEAT_FIRST\" : \"inflate::Dynamic block code description: repeat lengths with no first length\",\r\n    \"INCOMPLETE_CODES\" : \"inflate::Dynamic block code description: code lengths codes incomplete\",\r\n    \"INVALID_DYN_DISTANCE\": \"inflate::Dynamic block code description: invalid distance code lengths\",\r\n    \"INVALID_CODES_LEN\": \"inflate::Dynamic block code description: invalid literal/length code lengths\",\r\n    \"INVALID_STORE_BLOCK\" : \"inflate::Stored block length did not match one's complement\",\r\n    \"INVALID_BLOCK_TYPE\" : \"inflate::Invalid block type (type == 3)\",\r\n\r\n    /* ADM-ZIP error messages */\r\n    \"CANT_EXTRACT_FILE\" : \"Could not extract the file\",\r\n    \"CANT_OVERRIDE\" : \"Target file already exists\",\r\n    \"NO_ZIP\" : \"No zip file was loaded\",\r\n    \"NO_ENTRY\" : \"Entry doesn't exist\",\r\n    \"DIRECTORY_CONTENT_ERROR\" : \"A directory cannot have content\",\r\n    \"FILE_NOT_FOUND\" : \"File not found: %s\",\r\n    \"NOT_IMPLEMENTED\" : \"Not implemented\",\r\n    \"INVALID_FILENAME\" : \"Invalid filename\",\r\n    \"INVALID_FORMAT\" : \"Invalid or unsupported zip format. No END header found\"\r\n};","var fs = require(\"./fileSystem\").require(),\r\n    pth = require(\"path\");\r\n\t\r\nfs.existsSync = fs.existsSync || pth.existsSync;\r\n\r\nmodule.exports = function(/*String*/path) {\r\n\r\n    var _path = path || \"\",\r\n        _permissions = 0,\r\n        _obj = newAttr(),\r\n        _stat = null;\r\n\r\n    function newAttr() {\r\n        return {\r\n            directory : false,\r\n            readonly : false,\r\n            hidden : false,\r\n            executable : false,\r\n            mtime : 0,\r\n            atime : 0\r\n        }\r\n    }\r\n\r\n    if (_path && fs.existsSync(_path)) {\r\n        _stat = fs.statSync(_path);\r\n        _obj.directory = _stat.isDirectory();\r\n        _obj.mtime = _stat.mtime;\r\n        _obj.atime = _stat.atime;\r\n        _obj.executable = !!(1 & parseInt ((_stat.mode & parseInt (\"777\", 8)).toString (8)[0]));\r\n        _obj.readonly = !!(2 & parseInt ((_stat.mode & parseInt (\"777\", 8)).toString (8)[0]));\r\n        _obj.hidden = pth.basename(_path)[0] === \".\";\r\n    } else {\r\n        console.warn(\"Invalid path: \" + _path)\r\n    }\r\n\r\n    return {\r\n\r\n        get directory () {\r\n            return _obj.directory;\r\n        },\r\n\r\n        get readOnly () {\r\n            return _obj.readonly;\r\n        },\r\n\r\n        get hidden () {\r\n            return _obj.hidden;\r\n        },\r\n\r\n        get mtime () {\r\n            return _obj.mtime;\r\n        },\r\n\r\n        get atime () {\r\n           return _obj.atime;\r\n        },\r\n\r\n\r\n        get executable () {\r\n            return _obj.executable;\r\n        },\r\n\r\n        decodeAttributes : function(val) {\r\n\r\n        },\r\n\r\n        encodeAttributes : function (val) {\r\n\r\n        },\r\n\r\n        toString : function() {\r\n           return '{\\n' +\r\n               '\\t\"path\" : \"' + _path + \",\\n\" +\r\n               '\\t\"isDirectory\" : ' + _obj.directory + \",\\n\" +\r\n               '\\t\"isReadOnly\" : ' + _obj.readonly + \",\\n\" +\r\n               '\\t\"isHidden\" : ' + _obj.hidden + \",\\n\" +\r\n               '\\t\"isExecutable\" : ' + _obj.executable + \",\\n\" +\r\n               '\\t\"mTime\" : ' + _obj.mtime + \"\\n\" +\r\n               '\\t\"aTime\" : ' + _obj.atime + \"\\n\" +\r\n           '}';\r\n        }\r\n    }\r\n\r\n};\r\n","exports.require = function() {\r\n  var fs = require(\"fs\");\r\n  if (process.versions['electron']) {\r\n\t  try {\r\n\t    originalFs = require(\"original-fs\");\r\n\t    if (Object.keys(originalFs).length > 0) {\r\n\t      fs = originalFs;\r\n      }\r\n\t  } catch (e) {}\r\n  }\r\n  return fs\r\n};\r\n","module.exports = require(\"./utils\");\r\nmodule.exports.FileSystem = require(\"./fileSystem\");\r\nmodule.exports.Constants = require(\"./constants\");\r\nmodule.exports.Errors = require(\"./errors\");\r\nmodule.exports.FileAttr = require(\"./fattr\");","var fs = require(\"./fileSystem\").require(),\r\n    pth = require('path');\r\n\r\nfs.existsSync = fs.existsSync || pth.existsSync;\r\n\r\nmodule.exports = (function() {\r\n\r\n    var crcTable = [],\r\n        Constants = require('./constants'),\r\n        Errors = require('./errors'),\r\n\r\n        PATH_SEPARATOR = pth.sep;\r\n\r\n\r\n    function mkdirSync(/*String*/path) {\r\n        var resolvedPath = path.split(PATH_SEPARATOR)[0];\r\n        path.split(PATH_SEPARATOR).forEach(function(name) {\r\n            if (!name || name.substr(-1,1) === \":\") return;\r\n            resolvedPath += PATH_SEPARATOR + name;\r\n            var stat;\r\n            try {\r\n                stat = fs.statSync(resolvedPath);\r\n            } catch (e) {\r\n                fs.mkdirSync(resolvedPath);\r\n            }\r\n            if (stat && stat.isFile())\r\n                throw Errors.FILE_IN_THE_WAY.replace(\"%s\", resolvedPath);\r\n        });\r\n    }\r\n\r\n    function findSync(/*String*/dir, /*RegExp*/pattern, /*Boolean*/recoursive) {\r\n        if (typeof pattern === 'boolean') {\r\n            recoursive = pattern;\r\n            pattern = undefined;\r\n        }\r\n        var files = [];\r\n        fs.readdirSync(dir).forEach(function(file) {\r\n            var path = pth.join(dir, file);\r\n\r\n            if (fs.statSync(path).isDirectory() && recoursive)\r\n                files = files.concat(findSync(path, pattern, recoursive));\r\n\r\n            if (!pattern || pattern.test(path)) {\r\n                files.push(pth.normalize(path) + (fs.statSync(path).isDirectory() ? PATH_SEPARATOR : \"\"));\r\n            }\r\n\r\n        });\r\n        return files;\r\n    }\r\n\r\n    function readBigUInt64LE(/*Buffer*/buffer, /*int*/index) {\r\n        var slice = Buffer.from(buffer.slice(index, index + 8));\r\n        slice.swap64();\r\n\r\n        return parseInt(`0x${ slice.toString('hex') }`);\r\n    }\r\n\r\n    return {\r\n        makeDir : function(/*String*/path) {\r\n            mkdirSync(path);\r\n        },\r\n\r\n        crc32 : function(buf) {\r\n            if (typeof buf === 'string') {\r\n                buf = Buffer.alloc(buf.length, buf);\r\n            }\r\n            var b = Buffer.alloc(4);\r\n            if (!crcTable.length) {\r\n                for (var n = 0; n < 256; n++) {\r\n                    var c = n;\r\n                    for (var k = 8; --k >= 0;)  //\r\n                        if ((c & 1) !== 0)  { c = 0xedb88320 ^ (c >>> 1); } else { c = c >>> 1; }\r\n                    if (c < 0) {\r\n                        b.writeInt32LE(c, 0);\r\n                        c = b.readUInt32LE(0);\r\n                    }\r\n                    crcTable[n] = c;\r\n                }\r\n            }\r\n            var crc = 0, off = 0, len = buf.length, c1 = ~crc;\r\n            while(--len >= 0) c1 = crcTable[(c1 ^ buf[off++]) & 0xff] ^ (c1 >>> 8);\r\n            crc = ~c1;\r\n            b.writeInt32LE(crc & 0xffffffff, 0);\r\n            return b.readUInt32LE(0);\r\n        },\r\n\r\n        methodToString : function(/*Number*/method) {\r\n            switch (method) {\r\n                case Constants.STORED:\r\n                    return 'STORED (' + method + ')';\r\n                case Constants.DEFLATED:\r\n                    return 'DEFLATED (' + method + ')';\r\n                default:\r\n                    return 'UNSUPPORTED (' + method + ')';\r\n            }\r\n\r\n        },\r\n\r\n        writeFileTo : function(/*String*/path, /*Buffer*/content, /*Boolean*/overwrite, /*Number*/attr) {\r\n            if (fs.existsSync(path)) {\r\n                if (!overwrite)\r\n                    return false; // cannot overwrite\r\n\r\n                var stat = fs.statSync(path);\r\n                if (stat.isDirectory()) {\r\n                    return false;\r\n                }\r\n            }\r\n            var folder = pth.dirname(path);\r\n            if (!fs.existsSync(folder)) {\r\n                mkdirSync(folder);\r\n            }\r\n\r\n            var fd;\r\n            try {\r\n                fd = fs.openSync(path, 'w', 438); // 0666\r\n            } catch(e) {\r\n                fs.chmodSync(path, 438);\r\n                fd = fs.openSync(path, 'w', 438);\r\n            }\r\n            if (fd) {\r\n                try {\r\n                    fs.writeSync(fd, content, 0, content.length, 0);\r\n                }\r\n                catch (e){\r\n                    throw e;\r\n                }\r\n                finally {\r\n                    fs.closeSync(fd);\r\n                }\r\n            }\r\n            fs.chmodSync(path, attr || 438);\r\n            return true;\r\n        },\r\n\r\n        writeFileToAsync : function(/*String*/path, /*Buffer*/content, /*Boolean*/overwrite, /*Number*/attr, /*Function*/callback) {\r\n            if(typeof attr === 'function') {\r\n                callback = attr;\r\n                attr = undefined;\r\n            }\r\n\r\n            fs.exists(path, function(exists) {\r\n                if(exists && !overwrite)\r\n                    return callback(false);\r\n\r\n                fs.stat(path, function(err, stat) {\r\n                    if(exists &&stat.isDirectory()) {\r\n                        return callback(false);\r\n                    }\r\n\r\n                    var folder = pth.dirname(path);\r\n                    fs.exists(folder, function(exists) {\r\n                        if(!exists)\r\n                            mkdirSync(folder);\r\n\r\n                        fs.open(path, 'w', 438, function(err, fd) {\r\n                            if(err) {\r\n                                fs.chmod(path, 438, function() {\r\n                                    fs.open(path, 'w', 438, function(err, fd) {\r\n                                        fs.write(fd, content, 0, content.length, 0, function() {\r\n                                            fs.close(fd, function() {\r\n                                                fs.chmod(path, attr || 438, function() {\r\n                                                    callback(true);\r\n                                                })\r\n                                            });\r\n                                        });\r\n                                    });\r\n                                })\r\n                            } else {\r\n                                if(fd) {\r\n                                    fs.write(fd, content, 0, content.length, 0, function() {\r\n                                        fs.close(fd, function() {\r\n                                            fs.chmod(path, attr || 438, function() {\r\n                                                callback(true);\r\n                                            })\r\n                                        });\r\n                                    });\r\n                                } else {\r\n                                    fs.chmod(path, attr || 438, function() {\r\n                                        callback(true);\r\n                                    })\r\n                                }\r\n                            }\r\n                        });\r\n                    })\r\n                })\r\n            })\r\n        },\r\n\r\n        findFiles : function(/*String*/path) {\r\n            return findSync(path, true);\r\n        },\r\n\r\n        getAttributes : function(/*String*/path) {\r\n\r\n        },\r\n\r\n        setAttributes : function(/*String*/path) {\r\n\r\n        },\r\n\r\n        toBuffer : function(input) {\r\n            if (Buffer.isBuffer(input)) {\r\n                return input;\r\n            } else {\r\n                if (input.length === 0) {\r\n                    return Buffer.alloc(0)\r\n                }\r\n                return Buffer.from(input, 'utf8');\r\n            }\r\n        },\r\n\r\n        readBigUInt64LE,\r\n\r\n        Constants : Constants,\r\n        Errors : Errors\r\n    }\r\n})();\r\n","var Utils = require(\"./util\"),\r\n    Headers = require(\"./headers\"),\r\n    Constants = Utils.Constants,\r\n    Methods = require(\"./methods\");\r\n\r\nmodule.exports = function (/*Buffer*/input) {\r\n\r\n    var _entryHeader = new Headers.EntryHeader(),\r\n        _entryName = Buffer.alloc(0),\r\n        _comment = Buffer.alloc(0),\r\n        _isDirectory = false,\r\n        uncompressedData = null,\r\n        _extra = Buffer.alloc(0);\r\n\r\n    function getCompressedDataFromZip() {\r\n        if (!input || !Buffer.isBuffer(input)) {\r\n            return Buffer.alloc(0);\r\n        }\r\n        _entryHeader.loadDataHeaderFromBinary(input);\r\n        return input.slice(_entryHeader.realDataOffset, _entryHeader.realDataOffset + _entryHeader.compressedSize)\r\n    }\r\n\r\n    function crc32OK(data) {\r\n        // if bit 3 (0x08) of the general-purpose flags field is set, then the CRC-32 and file sizes are not known when the header is written\r\n        if ((_entryHeader.flags & 0x8) !== 0x8) {\r\n           if (Utils.crc32(data) !== _entryHeader.dataHeader.crc) {\r\n               return false;\r\n           }\r\n        } else {\r\n            // @TODO: load and check data descriptor header\r\n            // The fields in the local header are filled with zero, and the CRC-32 and size are appended in a 12-byte structure\r\n            // (optionally preceded by a 4-byte signature) immediately after the compressed data:\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function decompress(/*Boolean*/async, /*Function*/callback, /*String*/pass) {\r\n        if(typeof callback === 'undefined' && typeof async === 'string') {\r\n            pass=async;\r\n            async=void 0;\r\n        }\r\n        if (_isDirectory) {\r\n            if (async && callback) {\r\n                callback(Buffer.alloc(0), Utils.Errors.DIRECTORY_CONTENT_ERROR); //si added error.\r\n            }\r\n            return Buffer.alloc(0);\r\n        }\r\n\r\n        var compressedData = getCompressedDataFromZip();\r\n\r\n        if (compressedData.length === 0) {\r\n            // File is empty, nothing to decompress.\r\n            if (async && callback) callback(compressedData);\r\n            return compressedData;\r\n        }\r\n\r\n        var data = Buffer.alloc(_entryHeader.size);\r\n\r\n        switch (_entryHeader.method) {\r\n            case Utils.Constants.STORED:\r\n                compressedData.copy(data);\r\n                if (!crc32OK(data)) {\r\n                    if (async && callback) callback(data, Utils.Errors.BAD_CRC);//si added error\r\n                    return Utils.Errors.BAD_CRC;\r\n                } else {//si added otherwise did not seem to return data.\r\n                    if (async && callback) callback(data);\r\n                    return data;\r\n                }\r\n            case Utils.Constants.DEFLATED:\r\n                var inflater = new Methods.Inflater(compressedData);\r\n                if (!async) {\r\n                    var result = inflater.inflate(data);\r\n                    result.copy(data, 0);\r\n                    if (!crc32OK(data)) {\r\n                        console.warn(Utils.Errors.BAD_CRC + \" \" + _entryName.toString())\r\n                    }\r\n                    return data;\r\n                } else {\r\n                    inflater.inflateAsync(function(result) {\r\n                        result.copy(data, 0);\r\n                        if (!crc32OK(data)) {\r\n                            if (callback) callback(data, Utils.Errors.BAD_CRC); //si added error\r\n                        } else { //si added otherwise did not seem to return data.\r\n                            if (callback) callback(data);\r\n                        }\r\n                    })\r\n                }\r\n                break;\r\n            default:\r\n                if (async && callback) callback(Buffer.alloc(0), Utils.Errors.UNKNOWN_METHOD);\r\n                return Utils.Errors.UNKNOWN_METHOD;\r\n        }\r\n    }\r\n\r\n    function compress(/*Boolean*/async, /*Function*/callback) {\r\n        if ((!uncompressedData || !uncompressedData.length) && Buffer.isBuffer(input)) {\r\n            // no data set or the data wasn't changed to require recompression\r\n            if (async && callback) callback(getCompressedDataFromZip());\r\n            return getCompressedDataFromZip();\r\n        }\r\n\r\n        if (uncompressedData.length && !_isDirectory) {\r\n            var compressedData;\r\n            // Local file header\r\n            switch (_entryHeader.method) {\r\n                case Utils.Constants.STORED:\r\n                    _entryHeader.compressedSize = _entryHeader.size;\r\n\r\n                    compressedData = Buffer.alloc(uncompressedData.length);\r\n                    uncompressedData.copy(compressedData);\r\n\r\n                    if (async && callback) callback(compressedData);\r\n                    return compressedData;\r\n                default:\r\n                case Utils.Constants.DEFLATED:\r\n\r\n                    var deflater = new Methods.Deflater(uncompressedData);\r\n                    if (!async) {\r\n                        var deflated = deflater.deflate();\r\n                        _entryHeader.compressedSize = deflated.length;\r\n                        return deflated;\r\n                    } else {\r\n                        deflater.deflateAsync(function(data) {\r\n                            compressedData = Buffer.alloc(data.length);\r\n                            _entryHeader.compressedSize = data.length;\r\n                            data.copy(compressedData);\r\n                            callback && callback(compressedData);\r\n                        })\r\n                    }\r\n                    deflater = null;\r\n                    break;\r\n            }\r\n        } else {\r\n            if (async && callback) {\r\n                callback(Buffer.alloc(0));\r\n            } else {\r\n                return Buffer.alloc(0);\r\n            }\r\n        }\r\n    }\r\n\r\n    function readUInt64LE(buffer, offset) {\r\n        return (buffer.readUInt32LE(offset + 4) << 4) + buffer.readUInt32LE(offset);\r\n    }\r\n\r\n    function parseExtra(data) {\r\n        var offset = 0;\r\n        var signature, size, part;\r\n        while(offset<data.length) {\r\n            signature = data.readUInt16LE(offset);\r\n            offset += 2;\r\n            size = data.readUInt16LE(offset);\r\n            offset += 2;\r\n            part = data.slice(offset, offset+size);\r\n            offset += size;\r\n            if(Constants.ID_ZIP64 === signature) {\r\n                parseZip64ExtendedInformation(part);\r\n            }\r\n        }\r\n    }\r\n\r\n    //Override header field values with values from the ZIP64 extra field\r\n    function parseZip64ExtendedInformation(data) {\r\n        var size, compressedSize, offset, diskNumStart;\r\n\r\n        if(data.length >= Constants.EF_ZIP64_SCOMP) {\r\n            size = readUInt64LE(data, Constants.EF_ZIP64_SUNCOMP);\r\n            if(_entryHeader.size === Constants.EF_ZIP64_OR_32) {\r\n                _entryHeader.size = size;\r\n            }\r\n        }\r\n        if(data.length >= Constants.EF_ZIP64_RHO) {\r\n            compressedSize = readUInt64LE(data, Constants.EF_ZIP64_SCOMP);\r\n            if(_entryHeader.compressedSize === Constants.EF_ZIP64_OR_32) {\r\n                _entryHeader.compressedSize = compressedSize;\r\n            }\r\n        }\r\n        if(data.length >= Constants.EF_ZIP64_DSN) {\r\n            offset = readUInt64LE(data, Constants.EF_ZIP64_RHO);\r\n            if(_entryHeader.offset === Constants.EF_ZIP64_OR_32) {\r\n                _entryHeader.offset = offset;\r\n            }\r\n        }\r\n        if(data.length >= Constants.EF_ZIP64_DSN+4) {\r\n            diskNumStart = data.readUInt32LE(Constants.EF_ZIP64_DSN);\r\n            if(_entryHeader.diskNumStart === Constants.EF_ZIP64_OR_16) {\r\n                _entryHeader.diskNumStart = diskNumStart;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    return {\r\n        get entryName () { return _entryName.toString(); },\r\n        get rawEntryName() { return _entryName; },\r\n        set entryName (val) {\r\n            _entryName = Utils.toBuffer(val);\r\n            var lastChar = _entryName[_entryName.length - 1];\r\n            _isDirectory = (lastChar === 47) || (lastChar === 92);\r\n            _entryHeader.fileNameLength = _entryName.length;\r\n        },\r\n\r\n        get extra () { return _extra; },\r\n        set extra (val) {\r\n            _extra = val;\r\n            _entryHeader.extraLength = val.length;\r\n            parseExtra(val);\r\n        },\r\n\r\n        get comment () { return _comment.toString(); },\r\n        set comment (val) {\r\n            _comment = Utils.toBuffer(val);\r\n            _entryHeader.commentLength = _comment.length;\r\n        },\r\n\r\n        get name () { var n = _entryName.toString(); return _isDirectory ? n.substr(n.length - 1).split(\"/\").pop() : n.split(\"/\").pop(); },\r\n        get isDirectory () { return _isDirectory },\r\n\r\n        getCompressedData : function() {\r\n            return compress(false, null)\r\n        },\r\n\r\n        getCompressedDataAsync : function(/*Function*/callback) {\r\n            compress(true, callback)\r\n        },\r\n\r\n        setData : function(value) {\r\n            uncompressedData = Utils.toBuffer(value);\r\n            if (!_isDirectory && uncompressedData.length) {\r\n                _entryHeader.size = uncompressedData.length;\r\n                _entryHeader.method = Utils.Constants.DEFLATED;\r\n                _entryHeader.crc = Utils.crc32(value);\r\n                _entryHeader.changed = true;\r\n            } else { // folders and blank files should be stored\r\n                _entryHeader.method = Utils.Constants.STORED;\r\n            }\r\n        },\r\n\r\n        getData : function(pass) {\r\n            if (_entryHeader.changed) {\r\n\t\t\t\treturn uncompressedData;\r\n\t\t\t} else {\r\n\t\t\t\treturn decompress(false, null, pass);\r\n            }\r\n        },\r\n\r\n        getDataAsync : function(/*Function*/callback, pass) {\r\n\t\t\tif (_entryHeader.changed) {\r\n\t\t\t\tcallback(uncompressedData)\r\n\t\t\t} else {\r\n\t\t\t\tdecompress(true, callback, pass)\r\n            }\r\n        },\r\n\r\n        set attr(attr) { _entryHeader.attr = attr; },\r\n        get attr() { return _entryHeader.attr; },\r\n\r\n        set header(/*Buffer*/data) {\r\n            _entryHeader.loadFromBinary(data);\r\n        },\r\n\r\n        get header() {\r\n            return _entryHeader;\r\n        },\r\n\r\n        packHeader : function() {\r\n            var header = _entryHeader.entryHeaderToBinary();\r\n            // add\r\n            _entryName.copy(header, Utils.Constants.CENHDR);\r\n            if (_entryHeader.extraLength) {\r\n                _extra.copy(header, Utils.Constants.CENHDR + _entryName.length)\r\n            }\r\n            if (_entryHeader.commentLength) {\r\n                _comment.copy(header, Utils.Constants.CENHDR + _entryName.length + _entryHeader.extraLength, _comment.length);\r\n            }\r\n            return header;\r\n        },\r\n\r\n        toString : function() {\r\n            return '{\\n' +\r\n                '\\t\"entryName\" : \"' + _entryName.toString() + \"\\\",\\n\" +\r\n                '\\t\"name\" : \"' + (_isDirectory ? _entryName.toString().replace(/\\/$/, '').split(\"/\").pop() : _entryName.toString().split(\"/\").pop()) + \"\\\",\\n\" +\r\n                '\\t\"comment\" : \"' + _comment.toString() + \"\\\",\\n\" +\r\n                '\\t\"isDirectory\" : ' + _isDirectory + \",\\n\" +\r\n                '\\t\"header\" : ' + _entryHeader.toString().replace(/\\t/mg, \"\\t\\t\").replace(/}/mg, \"\\t}\")  + \",\\n\" +\r\n                '\\t\"compressedData\" : <' + (input && input.length  + \" bytes buffer\" || \"null\") + \">\\n\" +\r\n                '\\t\"data\" : <' + (uncompressedData && uncompressedData.length  + \" bytes buffer\" || \"null\") + \">\\n\" +\r\n                '}';\r\n        }\r\n    }\r\n};\r\n","var ZipEntry = require(\"./zipEntry\"),\r\n\tHeaders = require(\"./headers\"),\r\n\tUtils = require(\"./util\");\r\n\r\nmodule.exports = function (/*String|Buffer*/input, /*Number*/inputType) {\r\n\tvar entryList = [],\r\n\t\tentryTable = {},\r\n\t\t_comment = Buffer.alloc(0),\r\n\t\tfilename = \"\",\r\n\t\tfs = Utils.FileSystem.require(),\r\n\t\tinBuffer = null,\r\n\t\tmainHeader = new Headers.MainHeader(),\r\n\t\tloadedEntries = false;\r\n\r\n\tif (inputType === Utils.Constants.FILE) {\r\n\t\t// is a filename\r\n\t\tfilename = input;\r\n\t\tinBuffer = fs.readFileSync(filename);\r\n\t\treadMainHeader();\r\n\t} else if (inputType === Utils.Constants.BUFFER) {\r\n\t\t// is a memory buffer\r\n\t\tinBuffer = input;\r\n\t\treadMainHeader();\r\n\t} else {\r\n\t\t// none. is a new file\r\n\t\tloadedEntries = true;\r\n\t}\r\n\r\n\tfunction iterateEntries(callback) {\r\n\t\tconst totalEntries = mainHeader.diskEntries; // total number of entries\r\n\t\tlet index = mainHeader.offset; // offset of first CEN header\r\n\r\n\t\tfor (let i = 0; i < totalEntries; i++) {\r\n\t\t\tlet tmp = index;\r\n\t\t\tconst entry = new ZipEntry(inBuffer);\r\n\r\n\t\t\tentry.header = inBuffer.slice(tmp, tmp += Utils.Constants.CENHDR);\r\n\t\t\tentry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);\r\n\r\n\t\t\tindex += entry.header.entryHeaderSize;\r\n\r\n\t\t\tcallback(entry);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction readEntries() {\r\n\t\tloadedEntries = true;\r\n\t\tentryTable = {};\r\n\t\tentryList = new Array(mainHeader.diskEntries);  // total number of entries\r\n\t\tvar index = mainHeader.offset;  // offset of first CEN header\r\n\t\tfor (var i = 0; i < entryList.length; i++) {\r\n\r\n\t\t\tvar tmp = index,\r\n\t\t\t\tentry = new ZipEntry(inBuffer);\r\n\t\t\tentry.header = inBuffer.slice(tmp, tmp += Utils.Constants.CENHDR);\r\n\r\n\t\t\tentry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);\r\n\r\n\t\t\tif (entry.header.extraLength) {\r\n\t\t\t\tentry.extra = inBuffer.slice(tmp, tmp += entry.header.extraLength);\r\n\t\t\t}\r\n\r\n\t\t\tif (entry.header.commentLength)\r\n\t\t\t\tentry.comment = inBuffer.slice(tmp, tmp + entry.header.commentLength);\r\n\r\n\t\t\tindex += entry.header.entryHeaderSize;\r\n\r\n\t\t\tentryList[i] = entry;\r\n\t\t\tentryTable[entry.entryName] = entry;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction readMainHeader() {\r\n\t\tvar i = inBuffer.length - Utils.Constants.ENDHDR, // END header size\r\n\t\t\tmax = Math.max(0, i - 0xFFFF), // 0xFFFF is the max zip file comment length\r\n\t\t\tn = max,\r\n\t\t\tendStart = inBuffer.length,\r\n\t\t\tendOffset = -1, // Start offset of the END header\r\n\t\t\tcommentEnd = 0; \r\n\r\n\t\tfor (i; i >= n; i--) {\r\n\t\t\tif (inBuffer[i] !== 0x50) continue; // quick check that the byte is 'P'\r\n\t\t\tif (inBuffer.readUInt32LE(i) === Utils.Constants.ENDSIG) { // \"PK\\005\\006\"\r\n\t\t\t\tendOffset = i;\r\n\t\t\t\tcommentEnd = i;\r\n\t\t\t\tendStart = i + Utils.Constants.ENDHDR;\r\n\t\t\t\t// We already found a regular signature, let's look just a bit further to check if there's any zip64 signature\r\n\t\t\t\tn = i - Utils.Constants.END64HDR;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif (inBuffer.readUInt32LE(i) === Utils.Constants.END64SIG) {\r\n\t\t\t\t// Found a zip64 signature, let's continue reading the whole zip64 record\r\n\t\t\t\tn = max;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif (inBuffer.readUInt32LE(i) == Utils.Constants.ZIP64SIG) {\r\n\t\t\t\t// Found the zip64 record, let's determine it's size\r\n\t\t\t\tendOffset = i;\r\n\t\t\t\tendStart = i + Utils.readBigUInt64LE(inBuffer, i + Utils.Constants.ZIP64SIZE) + Utils.Constants.ZIP64LEAD;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!~endOffset)\r\n\t\t\tthrow Utils.Errors.INVALID_FORMAT;\r\n\r\n\t\tmainHeader.loadFromBinary(inBuffer.slice(endOffset, endStart));\r\n\t\tif (mainHeader.commentLength) {\r\n\t\t\t_comment = inBuffer.slice(commentEnd + Utils.Constants.ENDHDR);\r\n\t\t}\r\n\t\t// readEntries();\r\n\t}\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * Returns an array of ZipEntry objects existent in the current opened archive\r\n\t\t * @return Array\r\n\t\t */\r\n\t\tget entries() {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treadEntries();\r\n\t\t\t}\r\n\t\t\treturn entryList;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Archive comment\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tget comment() {\r\n\t\t\treturn _comment.toString();\r\n\t\t},\r\n\t\tset comment(val) {\r\n\t\t\tmainHeader.commentLength = val.length;\r\n\t\t\t_comment = val;\r\n\t\t},\r\n\r\n\t\tgetEntryCount: function() {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treturn mainHeader.diskEntries;\r\n\t\t\t}\r\n\r\n\t\t\treturn entryList.length;\r\n\t\t},\r\n\r\n\t\tforEach: function(callback) {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\titerateEntries(callback);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tentryList.forEach(callback);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns a reference to the entry with the given name or null if entry is inexistent\r\n\t\t *\r\n\t\t * @param entryName\r\n\t\t * @return ZipEntry\r\n\t\t */\r\n\t\tgetEntry: function (/*String*/entryName) {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treadEntries();\r\n\t\t\t}\r\n\t\t\treturn entryTable[entryName] || null;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds the given entry to the entry list\r\n\t\t *\r\n\t\t * @param entry\r\n\t\t */\r\n\t\tsetEntry: function (/*ZipEntry*/entry) {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treadEntries();\r\n\t\t\t}\r\n\t\t\tentryList.push(entry);\r\n\t\t\tentryTable[entry.entryName] = entry;\r\n\t\t\tmainHeader.totalEntries = entryList.length;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Removes the entry with the given name from the entry list.\r\n\t\t *\r\n\t\t * If the entry is a directory, then all nested files and directories will be removed\r\n\t\t * @param entryName\r\n\t\t */\r\n\t\tdeleteEntry: function (/*String*/entryName) {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treadEntries();\r\n\t\t\t}\r\n\t\t\tvar entry = entryTable[entryName];\r\n\t\t\tif (entry && entry.isDirectory) {\r\n\t\t\t\tvar _self = this;\r\n\t\t\t\tthis.getEntryChildren(entry).forEach(function (child) {\r\n\t\t\t\t\tif (child.entryName !== entryName) {\r\n\t\t\t\t\t\t_self.deleteEntry(child.entryName)\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tentryList.splice(entryList.indexOf(entry), 1);\r\n\t\t\tdelete(entryTable[entryName]);\r\n\t\t\tmainHeader.totalEntries = entryList.length;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t *  Iterates and returns all nested files and directories of the given entry\r\n\t\t *\r\n\t\t * @param entry\r\n\t\t * @return Array\r\n\t\t */\r\n\t\tgetEntryChildren: function (/*ZipEntry*/entry) {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treadEntries();\r\n\t\t\t}\r\n\t\t\tif (entry.isDirectory) {\r\n\t\t\t\tvar list = [],\r\n\t\t\t\t\tname = entry.entryName,\r\n\t\t\t\t\tlen = name.length;\r\n\r\n\t\t\t\tentryList.forEach(function (zipEntry) {\r\n\t\t\t\t\tif (zipEntry.entryName.substr(0, len) === name) {\r\n\t\t\t\t\t\tlist.push(zipEntry);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\treturn list;\r\n\t\t\t}\r\n\t\t\treturn []\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the zip file\r\n\t\t *\r\n\t\t * @return Buffer\r\n\t\t */\r\n\t\tcompressToBuffer: function () {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treadEntries();\r\n\t\t\t}\r\n\t\t\tif (entryList.length > 1) {\r\n\t\t\t\tentryList.sort(function (a, b) {\r\n\t\t\t\t\tvar nameA = a.entryName.toLowerCase();\r\n\t\t\t\t\tvar nameB = b.entryName.toLowerCase();\r\n\t\t\t\t\tif (nameA < nameB) {\r\n\t\t\t\t\t\treturn -1\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (nameA > nameB) {\r\n\t\t\t\t\t\treturn 1\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tvar totalSize = 0,\r\n\t\t\t\tdataBlock = [],\r\n\t\t\t\tentryHeaders = [],\r\n\t\t\t\tdindex = 0;\r\n\r\n\t\t\tmainHeader.size = 0;\r\n\t\t\tmainHeader.offset = 0;\r\n\r\n\t\t\tentryList.forEach(function (entry) {\r\n\t\t\t\t// compress data and set local and entry header accordingly. Reason why is called first\r\n\t\t\t\tvar compressedData = entry.getCompressedData();\r\n\t\t\t\t// data header\r\n\t\t\t\tentry.header.offset = dindex;\r\n\t\t\t\tvar dataHeader = entry.header.dataHeaderToBinary();\r\n\t\t\t\tvar entryNameLen = entry.rawEntryName.length;\r\n\t\t\t\tvar extra = entry.extra.toString();\r\n\t\t\t\tvar postHeader = Buffer.alloc(entryNameLen + extra.length);\r\n\t\t\t\tentry.rawEntryName.copy(postHeader, 0);\r\n\t\t\t\tpostHeader.fill(extra, entryNameLen);\r\n\r\n\t\t\t\tvar dataLength = dataHeader.length + postHeader.length + compressedData.length;\r\n\r\n\t\t\t\tdindex += dataLength;\r\n\r\n\t\t\t\tdataBlock.push(dataHeader);\r\n\t\t\t\tdataBlock.push(postHeader);\r\n\t\t\t\tdataBlock.push(compressedData);\r\n\r\n\t\t\t\tvar entryHeader = entry.packHeader();\r\n\t\t\t\tentryHeaders.push(entryHeader);\r\n\t\t\t\tmainHeader.size += entryHeader.length;\r\n\t\t\t\ttotalSize += (dataLength + entryHeader.length);\r\n\t\t\t});\r\n\r\n\t\t\ttotalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\r\n\t\t\t// point to end of data and beginning of central directory first record\r\n\t\t\tmainHeader.offset = dindex;\r\n\r\n\t\t\tdindex = 0;\r\n\t\t\tvar outBuffer = Buffer.alloc(totalSize);\r\n\t\t\tdataBlock.forEach(function (content) {\r\n\t\t\t\tcontent.copy(outBuffer, dindex); // write data blocks\r\n\t\t\t\tdindex += content.length;\r\n\t\t\t});\r\n\t\t\tentryHeaders.forEach(function (content) {\r\n\t\t\t\tcontent.copy(outBuffer, dindex); // write central directory entries\r\n\t\t\t\tdindex += content.length;\r\n\t\t\t});\r\n\r\n\t\t\tvar mh = mainHeader.toBinary();\r\n\t\t\tif (_comment) {\r\n\t\t\t\t_comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment\r\n\t\t\t}\r\n\r\n\t\t\tmh.copy(outBuffer, dindex); // write main header\r\n\r\n\t\t\treturn outBuffer\r\n\t\t},\r\n\r\n\t\ttoAsyncBuffer: function (/*Function*/onSuccess, /*Function*/onFail, /*Function*/onItemStart, /*Function*/onItemEnd) {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treadEntries();\r\n\t\t\t}\r\n\t\t\tif (entryList.length > 1) {\r\n\t\t\t\tentryList.sort(function (a, b) {\r\n\t\t\t\t\tvar nameA = a.entryName.toLowerCase();\r\n\t\t\t\t\tvar nameB = b.entryName.toLowerCase();\r\n\t\t\t\t\tif (nameA > nameB) {\r\n\t\t\t\t\t\treturn -1\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (nameA < nameB) {\r\n\t\t\t\t\t\treturn 1\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tvar totalSize = 0,\r\n\t\t\t\tdataBlock = [],\r\n\t\t\t\tentryHeaders = [],\r\n\t\t\t\tdindex = 0;\r\n\r\n\t\t\tmainHeader.size = 0;\r\n\t\t\tmainHeader.offset = 0;\r\n\r\n\t\t\tvar compress = function (entryList) {\r\n\t\t\t\tvar self = arguments.callee;\r\n\t\t\t\tif (entryList.length) {\r\n\t\t\t\t\tvar entry = entryList.pop();\r\n\t\t\t\t\tvar name = entry.entryName + entry.extra.toString();\r\n\t\t\t\t\tif (onItemStart) onItemStart(name);\r\n\t\t\t\t\tentry.getCompressedDataAsync(function (compressedData) {\r\n\t\t\t\t\t\tif (onItemEnd) onItemEnd(name);\r\n\r\n\t\t\t\t\t\tentry.header.offset = dindex;\r\n\t\t\t\t\t\t// data header\r\n\t\t\t\t\t\tvar dataHeader = entry.header.dataHeaderToBinary();\r\n\t\t\t\t\t\tvar postHeader;\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tpostHeader = Buffer.alloc(name.length, name);  // using alloc will work on node  5.x+\r\n\t\t\t\t\t\t} catch(e){\r\n\t\t\t\t\t\t\tpostHeader = new Buffer(name); // use deprecated method if alloc fails...\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar dataLength = dataHeader.length + postHeader.length + compressedData.length;\r\n\r\n\t\t\t\t\t\tdindex += dataLength;\r\n\r\n\t\t\t\t\t\tdataBlock.push(dataHeader);\r\n\t\t\t\t\t\tdataBlock.push(postHeader);\r\n\t\t\t\t\t\tdataBlock.push(compressedData);\r\n\r\n\t\t\t\t\t\tvar entryHeader = entry.packHeader();\r\n\t\t\t\t\t\tentryHeaders.push(entryHeader);\r\n\t\t\t\t\t\tmainHeader.size += entryHeader.length;\r\n\t\t\t\t\t\ttotalSize += (dataLength + entryHeader.length);\r\n\r\n\t\t\t\t\t\tif (entryList.length) {\r\n\t\t\t\t\t\t\tself(entryList);\r\n\t\t\t\t\t\t} else {\r\n\r\n\r\n\t\t\t\t\t\t\ttotalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\r\n\t\t\t\t\t\t\t// point to end of data and beginning of central directory first record\r\n\t\t\t\t\t\t\tmainHeader.offset = dindex;\r\n\r\n\t\t\t\t\t\t\tdindex = 0;\r\n\t\t\t\t\t\t\tvar outBuffer = Buffer.alloc(totalSize);\r\n\t\t\t\t\t\t\tdataBlock.forEach(function (content) {\r\n\t\t\t\t\t\t\t\tcontent.copy(outBuffer, dindex); // write data blocks\r\n\t\t\t\t\t\t\t\tdindex += content.length;\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\tentryHeaders.forEach(function (content) {\r\n\t\t\t\t\t\t\t\tcontent.copy(outBuffer, dindex); // write central directory entries\r\n\t\t\t\t\t\t\t\tdindex += content.length;\r\n\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\tvar mh = mainHeader.toBinary();\r\n\t\t\t\t\t\t\tif (_comment) {\r\n\t\t\t\t\t\t\t\t_comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tmh.copy(outBuffer, dindex); // write main header\r\n\r\n\t\t\t\t\t\t\tonSuccess(outBuffer);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tcompress(entryList);\r\n\t\t}\r\n\t}\r\n};\r\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"http\");;","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"url\");;","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"https\");;","import Stream from 'stream';\nimport http from 'http';\nimport Url from 'url';\nimport https from 'https';\nimport zlib from 'zlib';\n\n// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js\n\n// fix for \"Readable\" isn't a named export issue\nconst Readable = Stream.Readable;\n\nconst BUFFER = Symbol('buffer');\nconst TYPE = Symbol('type');\n\nclass Blob {\n\tconstructor() {\n\t\tthis[TYPE] = '';\n\n\t\tconst blobParts = arguments[0];\n\t\tconst options = arguments[1];\n\n\t\tconst buffers = [];\n\t\tlet size = 0;\n\n\t\tif (blobParts) {\n\t\t\tconst a = blobParts;\n\t\t\tconst length = Number(a.length);\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tconst element = a[i];\n\t\t\t\tlet buffer;\n\t\t\t\tif (element instanceof Buffer) {\n\t\t\t\t\tbuffer = element;\n\t\t\t\t} else if (ArrayBuffer.isView(element)) {\n\t\t\t\t\tbuffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);\n\t\t\t\t} else if (element instanceof ArrayBuffer) {\n\t\t\t\t\tbuffer = Buffer.from(element);\n\t\t\t\t} else if (element instanceof Blob) {\n\t\t\t\t\tbuffer = element[BUFFER];\n\t\t\t\t} else {\n\t\t\t\t\tbuffer = Buffer.from(typeof element === 'string' ? element : String(element));\n\t\t\t\t}\n\t\t\t\tsize += buffer.length;\n\t\t\t\tbuffers.push(buffer);\n\t\t\t}\n\t\t}\n\n\t\tthis[BUFFER] = Buffer.concat(buffers);\n\n\t\tlet type = options && options.type !== undefined && String(options.type).toLowerCase();\n\t\tif (type && !/[^\\u0020-\\u007E]/.test(type)) {\n\t\t\tthis[TYPE] = type;\n\t\t}\n\t}\n\tget size() {\n\t\treturn this[BUFFER].length;\n\t}\n\tget type() {\n\t\treturn this[TYPE];\n\t}\n\ttext() {\n\t\treturn Promise.resolve(this[BUFFER].toString());\n\t}\n\tarrayBuffer() {\n\t\tconst buf = this[BUFFER];\n\t\tconst ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\treturn Promise.resolve(ab);\n\t}\n\tstream() {\n\t\tconst readable = new Readable();\n\t\treadable._read = function () {};\n\t\treadable.push(this[BUFFER]);\n\t\treadable.push(null);\n\t\treturn readable;\n\t}\n\ttoString() {\n\t\treturn '[object Blob]';\n\t}\n\tslice() {\n\t\tconst size = this.size;\n\n\t\tconst start = arguments[0];\n\t\tconst end = arguments[1];\n\t\tlet relativeStart, relativeEnd;\n\t\tif (start === undefined) {\n\t\t\trelativeStart = 0;\n\t\t} else if (start < 0) {\n\t\t\trelativeStart = Math.max(size + start, 0);\n\t\t} else {\n\t\t\trelativeStart = Math.min(start, size);\n\t\t}\n\t\tif (end === undefined) {\n\t\t\trelativeEnd = size;\n\t\t} else if (end < 0) {\n\t\t\trelativeEnd = Math.max(size + end, 0);\n\t\t} else {\n\t\t\trelativeEnd = Math.min(end, size);\n\t\t}\n\t\tconst span = Math.max(relativeEnd - relativeStart, 0);\n\n\t\tconst buffer = this[BUFFER];\n\t\tconst slicedBuffer = buffer.slice(relativeStart, relativeStart + span);\n\t\tconst blob = new Blob([], { type: arguments[2] });\n\t\tblob[BUFFER] = slicedBuffer;\n\t\treturn blob;\n\t}\n}\n\nObject.defineProperties(Blob.prototype, {\n\tsize: { enumerable: true },\n\ttype: { enumerable: true },\n\tslice: { enumerable: true }\n});\n\nObject.defineProperty(Blob.prototype, Symbol.toStringTag, {\n\tvalue: 'Blob',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * fetch-error.js\n *\n * FetchError interface for operational errors\n */\n\n/**\n * Create FetchError instance\n *\n * @param   String      message      Error message for human\n * @param   String      type         Error type for machine\n * @param   String      systemError  For Node.js system error\n * @return  FetchError\n */\nfunction FetchError(message, type, systemError) {\n  Error.call(this, message);\n\n  this.message = message;\n  this.type = type;\n\n  // when err.type is `system`, err.code contains system error code\n  if (systemError) {\n    this.code = this.errno = systemError.code;\n  }\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nFetchError.prototype = Object.create(Error.prototype);\nFetchError.prototype.constructor = FetchError;\nFetchError.prototype.name = 'FetchError';\n\nlet convert;\ntry {\n\tconvert = require('encoding').convert;\n} catch (e) {}\n\nconst INTERNALS = Symbol('Body internals');\n\n// fix an issue where \"PassThrough\" isn't a named export for node <10\nconst PassThrough = Stream.PassThrough;\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nfunction Body(body) {\n\tvar _this = this;\n\n\tvar _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n\t    _ref$size = _ref.size;\n\n\tlet size = _ref$size === undefined ? 0 : _ref$size;\n\tvar _ref$timeout = _ref.timeout;\n\tlet timeout = _ref$timeout === undefined ? 0 : _ref$timeout;\n\n\tif (body == null) {\n\t\t// body is undefined or null\n\t\tbody = null;\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\tbody = Buffer.from(body.toString());\n\t} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\tbody = Buffer.from(body);\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n\t} else if (body instanceof Stream) ; else {\n\t\t// none of the above\n\t\t// coerce to string then buffer\n\t\tbody = Buffer.from(String(body));\n\t}\n\tthis[INTERNALS] = {\n\t\tbody,\n\t\tdisturbed: false,\n\t\terror: null\n\t};\n\tthis.size = size;\n\tthis.timeout = timeout;\n\n\tif (body instanceof Stream) {\n\t\tbody.on('error', function (err) {\n\t\t\tconst error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);\n\t\t\t_this[INTERNALS].error = error;\n\t\t});\n\t}\n}\n\nBody.prototype = {\n\tget body() {\n\t\treturn this[INTERNALS].body;\n\t},\n\n\tget bodyUsed() {\n\t\treturn this[INTERNALS].disturbed;\n\t},\n\n\t/**\n  * Decode response as ArrayBuffer\n  *\n  * @return  Promise\n  */\n\tarrayBuffer() {\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\t});\n\t},\n\n\t/**\n  * Return raw response as Blob\n  *\n  * @return Promise\n  */\n\tblob() {\n\t\tlet ct = this.headers && this.headers.get('content-type') || '';\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn Object.assign(\n\t\t\t// Prevent copying\n\t\t\tnew Blob([], {\n\t\t\t\ttype: ct.toLowerCase()\n\t\t\t}), {\n\t\t\t\t[BUFFER]: buf\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n  * Decode response as json\n  *\n  * @return  Promise\n  */\n\tjson() {\n\t\tvar _this2 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(buffer.toString());\n\t\t\t} catch (err) {\n\t\t\t\treturn Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n  * Decode response as text\n  *\n  * @return  Promise\n  */\n\ttext() {\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn buffer.toString();\n\t\t});\n\t},\n\n\t/**\n  * Decode response as buffer (non-spec api)\n  *\n  * @return  Promise\n  */\n\tbuffer() {\n\t\treturn consumeBody.call(this);\n\t},\n\n\t/**\n  * Decode response as text, while automatically detecting the encoding and\n  * trying to decode to UTF-8 (non-spec api)\n  *\n  * @return  Promise\n  */\n\ttextConverted() {\n\t\tvar _this3 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn convertBody(buffer, _this3.headers);\n\t\t});\n\t}\n};\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n\tbody: { enumerable: true },\n\tbodyUsed: { enumerable: true },\n\tarrayBuffer: { enumerable: true },\n\tblob: { enumerable: true },\n\tjson: { enumerable: true },\n\ttext: { enumerable: true }\n});\n\nBody.mixIn = function (proto) {\n\tfor (const name of Object.getOwnPropertyNames(Body.prototype)) {\n\t\t// istanbul ignore else: future proof\n\t\tif (!(name in proto)) {\n\t\t\tconst desc = Object.getOwnPropertyDescriptor(Body.prototype, name);\n\t\t\tObject.defineProperty(proto, name, desc);\n\t\t}\n\t}\n};\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return  Promise\n */\nfunction consumeBody() {\n\tvar _this4 = this;\n\n\tif (this[INTERNALS].disturbed) {\n\t\treturn Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));\n\t}\n\n\tthis[INTERNALS].disturbed = true;\n\n\tif (this[INTERNALS].error) {\n\t\treturn Body.Promise.reject(this[INTERNALS].error);\n\t}\n\n\tlet body = this.body;\n\n\t// body is null\n\tif (body === null) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is blob\n\tif (isBlob(body)) {\n\t\tbody = body.stream();\n\t}\n\n\t// body is buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn Body.Promise.resolve(body);\n\t}\n\n\t// istanbul ignore if: should never happen\n\tif (!(body instanceof Stream)) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is stream\n\t// get ready to actually consume the body\n\tlet accum = [];\n\tlet accumBytes = 0;\n\tlet abort = false;\n\n\treturn new Body.Promise(function (resolve, reject) {\n\t\tlet resTimeout;\n\n\t\t// allow timeout on slow response body\n\t\tif (_this4.timeout) {\n\t\t\tresTimeout = setTimeout(function () {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));\n\t\t\t}, _this4.timeout);\n\t\t}\n\n\t\t// handle stream errors\n\t\tbody.on('error', function (err) {\n\t\t\tif (err.name === 'AbortError') {\n\t\t\t\t// if the request was aborted, reject with this Error\n\t\t\t\tabort = true;\n\t\t\t\treject(err);\n\t\t\t} else {\n\t\t\t\t// other errors, such as incorrect content-encoding\n\t\t\t\treject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\n\t\tbody.on('data', function (chunk) {\n\t\t\tif (abort || chunk === null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_this4.size && accumBytes + chunk.length > _this4.size) {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\taccumBytes += chunk.length;\n\t\t\taccum.push(chunk);\n\t\t});\n\n\t\tbody.on('end', function () {\n\t\t\tif (abort) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclearTimeout(resTimeout);\n\n\t\t\ttry {\n\t\t\t\tresolve(Buffer.concat(accum, accumBytes));\n\t\t\t} catch (err) {\n\t\t\t\t// handle streams that have accumulated too much data (issue #414)\n\t\t\t\treject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param   Buffer  buffer    Incoming buffer\n * @param   String  encoding  Target encoding\n * @return  String\n */\nfunction convertBody(buffer, headers) {\n\tif (typeof convert !== 'function') {\n\t\tthrow new Error('The package `encoding` must be installed to use the textConverted() function');\n\t}\n\n\tconst ct = headers.get('content-type');\n\tlet charset = 'utf-8';\n\tlet res, str;\n\n\t// header\n\tif (ct) {\n\t\tres = /charset=([^;]*)/i.exec(ct);\n\t}\n\n\t// no charset in content type, peek at response body for at most 1024 bytes\n\tstr = buffer.slice(0, 1024).toString();\n\n\t// html5\n\tif (!res && str) {\n\t\tres = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// html4\n\tif (!res && str) {\n\t\tres = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n\t\tif (!res) {\n\t\t\tres = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str);\n\t\t\tif (res) {\n\t\t\t\tres.pop(); // drop last quote\n\t\t\t}\n\t\t}\n\n\t\tif (res) {\n\t\t\tres = /charset=(.*)/i.exec(res.pop());\n\t\t}\n\t}\n\n\t// xml\n\tif (!res && str) {\n\t\tres = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// found charset\n\tif (res) {\n\t\tcharset = res.pop();\n\n\t\t// prevent decode issues when sites use incorrect encoding\n\t\t// ref: https://hsivonen.fi/encoding-menu/\n\t\tif (charset === 'gb2312' || charset === 'gbk') {\n\t\t\tcharset = 'gb18030';\n\t\t}\n\t}\n\n\t// turn raw buffers into a single utf-8 buffer\n\treturn convert(buffer, 'UTF-8', charset).toString();\n}\n\n/**\n * Detect a URLSearchParams object\n * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143\n *\n * @param   Object  obj     Object to detect by type or brand\n * @return  String\n */\nfunction isURLSearchParams(obj) {\n\t// Duck-typing as a necessary condition.\n\tif (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {\n\t\treturn false;\n\t}\n\n\t// Brand-checking and more duck-typing as optional condition.\n\treturn obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';\n}\n\n/**\n * Check if `obj` is a W3C `Blob` object (which `File` inherits from)\n * @param  {*} obj\n * @return {boolean}\n */\nfunction isBlob(obj) {\n\treturn typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed  instance  Response or Request instance\n * @return  Mixed\n */\nfunction clone(instance) {\n\tlet p1, p2;\n\tlet body = instance.body;\n\n\t// don't allow cloning a used body\n\tif (instance.bodyUsed) {\n\t\tthrow new Error('cannot clone body after it is used');\n\t}\n\n\t// check that body is a stream and not form-data object\n\t// note: we can't clone the form-data object without having it as a dependency\n\tif (body instanceof Stream && typeof body.getBoundary !== 'function') {\n\t\t// tee instance body\n\t\tp1 = new PassThrough();\n\t\tp2 = new PassThrough();\n\t\tbody.pipe(p1);\n\t\tbody.pipe(p2);\n\t\t// set instance body to teed body and return the other teed body\n\t\tinstance[INTERNALS].body = p1;\n\t\tbody = p2;\n\t}\n\n\treturn body;\n}\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param   Mixed  instance  Any options.body input\n */\nfunction extractContentType(body) {\n\tif (body === null) {\n\t\t// body is null\n\t\treturn null;\n\t} else if (typeof body === 'string') {\n\t\t// body is string\n\t\treturn 'text/plain;charset=UTF-8';\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t} else if (isBlob(body)) {\n\t\t// body is blob\n\t\treturn body.type || null;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn null;\n\t} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\treturn null;\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\treturn null;\n\t} else if (typeof body.getBoundary === 'function') {\n\t\t// detect form data input from form-data module\n\t\treturn `multipart/form-data;boundary=${body.getBoundary()}`;\n\t} else if (body instanceof Stream) {\n\t\t// body is stream\n\t\t// can't really do much about this\n\t\treturn null;\n\t} else {\n\t\t// Body constructor defaults other things to string\n\t\treturn 'text/plain;charset=UTF-8';\n\t}\n}\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param   Body    instance   Instance of Body\n * @return  Number?            Number of bytes, or null if not possible\n */\nfunction getTotalBytes(instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\treturn 0;\n\t} else if (isBlob(body)) {\n\t\treturn body.size;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn body.length;\n\t} else if (body && typeof body.getLengthSync === 'function') {\n\t\t// detect form data input from form-data module\n\t\tif (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x\n\t\tbody.hasKnownLength && body.hasKnownLength()) {\n\t\t\t// 2.x\n\t\t\treturn body.getLengthSync();\n\t\t}\n\t\treturn null;\n\t} else {\n\t\t// body is stream\n\t\treturn null;\n\t}\n}\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param   Body    instance   Instance of Body\n * @return  Void\n */\nfunction writeToStream(dest, instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\tdest.end();\n\t} else if (isBlob(body)) {\n\t\tbody.stream().pipe(dest);\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\tdest.write(body);\n\t\tdest.end();\n\t} else {\n\t\t// body is stream\n\t\tbody.pipe(dest);\n\t}\n}\n\n// expose Promise\nBody.Promise = global.Promise;\n\n/**\n * headers.js\n *\n * Headers class offers convenient helpers\n */\n\nconst invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/;\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n\nfunction validateName(name) {\n\tname = `${name}`;\n\tif (invalidTokenRegex.test(name) || name === '') {\n\t\tthrow new TypeError(`${name} is not a legal HTTP header name`);\n\t}\n}\n\nfunction validateValue(value) {\n\tvalue = `${value}`;\n\tif (invalidHeaderCharRegex.test(value)) {\n\t\tthrow new TypeError(`${value} is not a legal HTTP header value`);\n\t}\n}\n\n/**\n * Find the key in the map object given a header name.\n *\n * Returns undefined if not found.\n *\n * @param   String  name  Header name\n * @return  String|Undefined\n */\nfunction find(map, name) {\n\tname = name.toLowerCase();\n\tfor (const key in map) {\n\t\tif (key.toLowerCase() === name) {\n\t\t\treturn key;\n\t\t}\n\t}\n\treturn undefined;\n}\n\nconst MAP = Symbol('map');\nclass Headers {\n\t/**\n  * Headers class\n  *\n  * @param   Object  headers  Response headers\n  * @return  Void\n  */\n\tconstructor() {\n\t\tlet init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n\t\tthis[MAP] = Object.create(null);\n\n\t\tif (init instanceof Headers) {\n\t\t\tconst rawHeaders = init.raw();\n\t\t\tconst headerNames = Object.keys(rawHeaders);\n\n\t\t\tfor (const headerName of headerNames) {\n\t\t\t\tfor (const value of rawHeaders[headerName]) {\n\t\t\t\t\tthis.append(headerName, value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// We don't worry about converting prop to ByteString here as append()\n\t\t// will handle it.\n\t\tif (init == null) ; else if (typeof init === 'object') {\n\t\t\tconst method = init[Symbol.iterator];\n\t\t\tif (method != null) {\n\t\t\t\tif (typeof method !== 'function') {\n\t\t\t\t\tthrow new TypeError('Header pairs must be iterable');\n\t\t\t\t}\n\n\t\t\t\t// sequence<sequence<ByteString>>\n\t\t\t\t// Note: per spec we have to first exhaust the lists then process them\n\t\t\t\tconst pairs = [];\n\t\t\t\tfor (const pair of init) {\n\t\t\t\t\tif (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be iterable');\n\t\t\t\t\t}\n\t\t\t\t\tpairs.push(Array.from(pair));\n\t\t\t\t}\n\n\t\t\t\tfor (const pair of pairs) {\n\t\t\t\t\tif (pair.length !== 2) {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be a name/value tuple');\n\t\t\t\t\t}\n\t\t\t\t\tthis.append(pair[0], pair[1]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// record<ByteString, ByteString>\n\t\t\t\tfor (const key of Object.keys(init)) {\n\t\t\t\t\tconst value = init[key];\n\t\t\t\t\tthis.append(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Provided initializer must be an object');\n\t\t}\n\t}\n\n\t/**\n  * Return combined header value given name\n  *\n  * @param   String  name  Header name\n  * @return  Mixed\n  */\n\tget(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key === undefined) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this[MAP][key].join(', ');\n\t}\n\n\t/**\n  * Iterate over all headers\n  *\n  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\n  * @param   Boolean   thisArg   `this` context for callback function\n  * @return  Void\n  */\n\tforEach(callback) {\n\t\tlet thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n\t\tlet pairs = getHeaders(this);\n\t\tlet i = 0;\n\t\twhile (i < pairs.length) {\n\t\t\tvar _pairs$i = pairs[i];\n\t\t\tconst name = _pairs$i[0],\n\t\t\t      value = _pairs$i[1];\n\n\t\t\tcallback.call(thisArg, value, name, this);\n\t\t\tpairs = getHeaders(this);\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/**\n  * Overwrite header values given name\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tset(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tthis[MAP][key !== undefined ? key : name] = [value];\n\t}\n\n\t/**\n  * Append a value onto existing header\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tappend(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tthis[MAP][key].push(value);\n\t\t} else {\n\t\t\tthis[MAP][name] = [value];\n\t\t}\n\t}\n\n\t/**\n  * Check for header name existence\n  *\n  * @param   String   name  Header name\n  * @return  Boolean\n  */\n\thas(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\treturn find(this[MAP], name) !== undefined;\n\t}\n\n\t/**\n  * Delete all header values given name\n  *\n  * @param   String  name  Header name\n  * @return  Void\n  */\n\tdelete(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tdelete this[MAP][key];\n\t\t}\n\t}\n\n\t/**\n  * Return raw headers (non-spec api)\n  *\n  * @return  Object\n  */\n\traw() {\n\t\treturn this[MAP];\n\t}\n\n\t/**\n  * Get an iterator on keys.\n  *\n  * @return  Iterator\n  */\n\tkeys() {\n\t\treturn createHeadersIterator(this, 'key');\n\t}\n\n\t/**\n  * Get an iterator on values.\n  *\n  * @return  Iterator\n  */\n\tvalues() {\n\t\treturn createHeadersIterator(this, 'value');\n\t}\n\n\t/**\n  * Get an iterator on entries.\n  *\n  * This is the default iterator of the Headers object.\n  *\n  * @return  Iterator\n  */\n\t[Symbol.iterator]() {\n\t\treturn createHeadersIterator(this, 'key+value');\n\t}\n}\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator];\n\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n\tvalue: 'Headers',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Headers.prototype, {\n\tget: { enumerable: true },\n\tforEach: { enumerable: true },\n\tset: { enumerable: true },\n\tappend: { enumerable: true },\n\thas: { enumerable: true },\n\tdelete: { enumerable: true },\n\tkeys: { enumerable: true },\n\tvalues: { enumerable: true },\n\tentries: { enumerable: true }\n});\n\nfunction getHeaders(headers) {\n\tlet kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';\n\n\tconst keys = Object.keys(headers[MAP]).sort();\n\treturn keys.map(kind === 'key' ? function (k) {\n\t\treturn k.toLowerCase();\n\t} : kind === 'value' ? function (k) {\n\t\treturn headers[MAP][k].join(', ');\n\t} : function (k) {\n\t\treturn [k.toLowerCase(), headers[MAP][k].join(', ')];\n\t});\n}\n\nconst INTERNAL = Symbol('internal');\n\nfunction createHeadersIterator(target, kind) {\n\tconst iterator = Object.create(HeadersIteratorPrototype);\n\titerator[INTERNAL] = {\n\t\ttarget,\n\t\tkind,\n\t\tindex: 0\n\t};\n\treturn iterator;\n}\n\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n\tnext() {\n\t\t// istanbul ignore if\n\t\tif (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n\t\t\tthrow new TypeError('Value of `this` is not a HeadersIterator');\n\t\t}\n\n\t\tvar _INTERNAL = this[INTERNAL];\n\t\tconst target = _INTERNAL.target,\n\t\t      kind = _INTERNAL.kind,\n\t\t      index = _INTERNAL.index;\n\n\t\tconst values = getHeaders(target, kind);\n\t\tconst len = values.length;\n\t\tif (index >= len) {\n\t\t\treturn {\n\t\t\t\tvalue: undefined,\n\t\t\t\tdone: true\n\t\t\t};\n\t\t}\n\n\t\tthis[INTERNAL].index = index + 1;\n\n\t\treturn {\n\t\t\tvalue: values[index],\n\t\t\tdone: false\n\t\t};\n\t}\n}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\n\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n\tvalue: 'HeadersIterator',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * Export the Headers object in a form that Node.js can consume.\n *\n * @param   Headers  headers\n * @return  Object\n */\nfunction exportNodeCompatibleHeaders(headers) {\n\tconst obj = Object.assign({ __proto__: null }, headers[MAP]);\n\n\t// http.request() only supports string as Host header. This hack makes\n\t// specifying custom Host header possible.\n\tconst hostHeaderKey = find(headers[MAP], 'Host');\n\tif (hostHeaderKey !== undefined) {\n\t\tobj[hostHeaderKey] = obj[hostHeaderKey][0];\n\t}\n\n\treturn obj;\n}\n\n/**\n * Create a Headers object from an object of headers, ignoring those that do\n * not conform to HTTP grammar productions.\n *\n * @param   Object  obj  Object of headers\n * @return  Headers\n */\nfunction createHeadersLenient(obj) {\n\tconst headers = new Headers();\n\tfor (const name of Object.keys(obj)) {\n\t\tif (invalidTokenRegex.test(name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (Array.isArray(obj[name])) {\n\t\t\tfor (const val of obj[name]) {\n\t\t\t\tif (invalidHeaderCharRegex.test(val)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (headers[MAP][name] === undefined) {\n\t\t\t\t\theaders[MAP][name] = [val];\n\t\t\t\t} else {\n\t\t\t\t\theaders[MAP][name].push(val);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!invalidHeaderCharRegex.test(obj[name])) {\n\t\t\theaders[MAP][name] = [obj[name]];\n\t\t}\n\t}\n\treturn headers;\n}\n\nconst INTERNALS$1 = Symbol('Response internals');\n\n// fix an issue where \"STATUS_CODES\" aren't a named export for node <10\nconst STATUS_CODES = http.STATUS_CODES;\n\n/**\n * Response class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nclass Response {\n\tconstructor() {\n\t\tlet body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\tlet opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tBody.call(this, body, opts);\n\n\t\tconst status = opts.status || 200;\n\t\tconst headers = new Headers(opts.headers);\n\n\t\tif (body != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(body);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tthis[INTERNALS$1] = {\n\t\t\turl: opts.url,\n\t\t\tstatus,\n\t\t\tstatusText: opts.statusText || STATUS_CODES[status],\n\t\t\theaders,\n\t\t\tcounter: opts.counter\n\t\t};\n\t}\n\n\tget url() {\n\t\treturn this[INTERNALS$1].url || '';\n\t}\n\n\tget status() {\n\t\treturn this[INTERNALS$1].status;\n\t}\n\n\t/**\n  * Convenience property representing if the request ended normally\n  */\n\tget ok() {\n\t\treturn this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;\n\t}\n\n\tget redirected() {\n\t\treturn this[INTERNALS$1].counter > 0;\n\t}\n\n\tget statusText() {\n\t\treturn this[INTERNALS$1].statusText;\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$1].headers;\n\t}\n\n\t/**\n  * Clone this response\n  *\n  * @return  Response\n  */\n\tclone() {\n\t\treturn new Response(clone(this), {\n\t\t\turl: this.url,\n\t\t\tstatus: this.status,\n\t\t\tstatusText: this.statusText,\n\t\t\theaders: this.headers,\n\t\t\tok: this.ok,\n\t\t\tredirected: this.redirected\n\t\t});\n\t}\n}\n\nBody.mixIn(Response.prototype);\n\nObject.defineProperties(Response.prototype, {\n\turl: { enumerable: true },\n\tstatus: { enumerable: true },\n\tok: { enumerable: true },\n\tredirected: { enumerable: true },\n\tstatusText: { enumerable: true },\n\theaders: { enumerable: true },\n\tclone: { enumerable: true }\n});\n\nObject.defineProperty(Response.prototype, Symbol.toStringTag, {\n\tvalue: 'Response',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nconst INTERNALS$2 = Symbol('Request internals');\n\n// fix an issue where \"format\", \"parse\" aren't a named export for node <10\nconst parse_url = Url.parse;\nconst format_url = Url.format;\n\nconst streamDestructionSupported = 'destroy' in Stream.Readable.prototype;\n\n/**\n * Check if a value is an instance of Request.\n *\n * @param   Mixed   input\n * @return  Boolean\n */\nfunction isRequest(input) {\n\treturn typeof input === 'object' && typeof input[INTERNALS$2] === 'object';\n}\n\nfunction isAbortSignal(signal) {\n\tconst proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);\n\treturn !!(proto && proto.constructor.name === 'AbortSignal');\n}\n\n/**\n * Request class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */\nclass Request {\n\tconstructor(input) {\n\t\tlet init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tlet parsedURL;\n\n\t\t// normalize input\n\t\tif (!isRequest(input)) {\n\t\t\tif (input && input.href) {\n\t\t\t\t// in order to support Node.js' Url objects; though WHATWG's URL objects\n\t\t\t\t// will fall into this branch also (since their `toString()` will return\n\t\t\t\t// `href` property anyway)\n\t\t\t\tparsedURL = parse_url(input.href);\n\t\t\t} else {\n\t\t\t\t// coerce input to a string before attempting to parse\n\t\t\t\tparsedURL = parse_url(`${input}`);\n\t\t\t}\n\t\t\tinput = {};\n\t\t} else {\n\t\t\tparsedURL = parse_url(input.url);\n\t\t}\n\n\t\tlet method = init.method || input.method || 'GET';\n\t\tmethod = method.toUpperCase();\n\n\t\tif ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {\n\t\t\tthrow new TypeError('Request with GET/HEAD method cannot have body');\n\t\t}\n\n\t\tlet inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n\n\t\tBody.call(this, inputBody, {\n\t\t\ttimeout: init.timeout || input.timeout || 0,\n\t\t\tsize: init.size || input.size || 0\n\t\t});\n\n\t\tconst headers = new Headers(init.headers || input.headers || {});\n\n\t\tif (inputBody != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(inputBody);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tlet signal = isRequest(input) ? input.signal : null;\n\t\tif ('signal' in init) signal = init.signal;\n\n\t\tif (signal != null && !isAbortSignal(signal)) {\n\t\t\tthrow new TypeError('Expected signal to be an instanceof AbortSignal');\n\t\t}\n\n\t\tthis[INTERNALS$2] = {\n\t\t\tmethod,\n\t\t\tredirect: init.redirect || input.redirect || 'follow',\n\t\t\theaders,\n\t\t\tparsedURL,\n\t\t\tsignal\n\t\t};\n\n\t\t// node-fetch-only options\n\t\tthis.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\n\t\tthis.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;\n\t\tthis.counter = init.counter || input.counter || 0;\n\t\tthis.agent = init.agent || input.agent;\n\t}\n\n\tget method() {\n\t\treturn this[INTERNALS$2].method;\n\t}\n\n\tget url() {\n\t\treturn format_url(this[INTERNALS$2].parsedURL);\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$2].headers;\n\t}\n\n\tget redirect() {\n\t\treturn this[INTERNALS$2].redirect;\n\t}\n\n\tget signal() {\n\t\treturn this[INTERNALS$2].signal;\n\t}\n\n\t/**\n  * Clone this request\n  *\n  * @return  Request\n  */\n\tclone() {\n\t\treturn new Request(this);\n\t}\n}\n\nBody.mixIn(Request.prototype);\n\nObject.defineProperty(Request.prototype, Symbol.toStringTag, {\n\tvalue: 'Request',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Request.prototype, {\n\tmethod: { enumerable: true },\n\turl: { enumerable: true },\n\theaders: { enumerable: true },\n\tredirect: { enumerable: true },\n\tclone: { enumerable: true },\n\tsignal: { enumerable: true }\n});\n\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param   Request  A Request instance\n * @return  Object   The options object to be passed to http.request\n */\nfunction getNodeRequestOptions(request) {\n\tconst parsedURL = request[INTERNALS$2].parsedURL;\n\tconst headers = new Headers(request[INTERNALS$2].headers);\n\n\t// fetch step 1.3\n\tif (!headers.has('Accept')) {\n\t\theaders.set('Accept', '*/*');\n\t}\n\n\t// Basic fetch\n\tif (!parsedURL.protocol || !parsedURL.hostname) {\n\t\tthrow new TypeError('Only absolute URLs are supported');\n\t}\n\n\tif (!/^https?:$/.test(parsedURL.protocol)) {\n\t\tthrow new TypeError('Only HTTP(S) protocols are supported');\n\t}\n\n\tif (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {\n\t\tthrow new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');\n\t}\n\n\t// HTTP-network-or-cache fetch steps 2.4-2.7\n\tlet contentLengthValue = null;\n\tif (request.body == null && /^(POST|PUT)$/i.test(request.method)) {\n\t\tcontentLengthValue = '0';\n\t}\n\tif (request.body != null) {\n\t\tconst totalBytes = getTotalBytes(request);\n\t\tif (typeof totalBytes === 'number') {\n\t\t\tcontentLengthValue = String(totalBytes);\n\t\t}\n\t}\n\tif (contentLengthValue) {\n\t\theaders.set('Content-Length', contentLengthValue);\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.11\n\tif (!headers.has('User-Agent')) {\n\t\theaders.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.15\n\tif (request.compress && !headers.has('Accept-Encoding')) {\n\t\theaders.set('Accept-Encoding', 'gzip,deflate');\n\t}\n\n\tlet agent = request.agent;\n\tif (typeof agent === 'function') {\n\t\tagent = agent(parsedURL);\n\t}\n\n\tif (!headers.has('Connection') && !agent) {\n\t\theaders.set('Connection', 'close');\n\t}\n\n\t// HTTP-network fetch step 4.2\n\t// chunked encoding is handled by Node.js\n\n\treturn Object.assign({}, parsedURL, {\n\t\tmethod: request.method,\n\t\theaders: exportNodeCompatibleHeaders(headers),\n\t\tagent\n\t});\n}\n\n/**\n * abort-error.js\n *\n * AbortError interface for cancelled requests\n */\n\n/**\n * Create AbortError instance\n *\n * @param   String      message      Error message for human\n * @return  AbortError\n */\nfunction AbortError(message) {\n  Error.call(this, message);\n\n  this.type = 'aborted';\n  this.message = message;\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nAbortError.prototype = Object.create(Error.prototype);\nAbortError.prototype.constructor = AbortError;\nAbortError.prototype.name = 'AbortError';\n\n// fix an issue where \"PassThrough\", \"resolve\" aren't a named export for node <10\nconst PassThrough$1 = Stream.PassThrough;\nconst resolve_url = Url.resolve;\n\n/**\n * Fetch function\n *\n * @param   Mixed    url   Absolute url or Request instance\n * @param   Object   opts  Fetch options\n * @return  Promise\n */\nfunction fetch(url, opts) {\n\n\t// allow custom promise\n\tif (!fetch.Promise) {\n\t\tthrow new Error('native promise missing, set fetch.Promise to your favorite alternative');\n\t}\n\n\tBody.Promise = fetch.Promise;\n\n\t// wrap http.request into fetch\n\treturn new fetch.Promise(function (resolve, reject) {\n\t\t// build request object\n\t\tconst request = new Request(url, opts);\n\t\tconst options = getNodeRequestOptions(request);\n\n\t\tconst send = (options.protocol === 'https:' ? https : http).request;\n\t\tconst signal = request.signal;\n\n\t\tlet response = null;\n\n\t\tconst abort = function abort() {\n\t\t\tlet error = new AbortError('The user aborted a request.');\n\t\t\treject(error);\n\t\t\tif (request.body && request.body instanceof Stream.Readable) {\n\t\t\t\trequest.body.destroy(error);\n\t\t\t}\n\t\t\tif (!response || !response.body) return;\n\t\t\tresponse.body.emit('error', error);\n\t\t};\n\n\t\tif (signal && signal.aborted) {\n\t\t\tabort();\n\t\t\treturn;\n\t\t}\n\n\t\tconst abortAndFinalize = function abortAndFinalize() {\n\t\t\tabort();\n\t\t\tfinalize();\n\t\t};\n\n\t\t// send request\n\t\tconst req = send(options);\n\t\tlet reqTimeout;\n\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', abortAndFinalize);\n\t\t}\n\n\t\tfunction finalize() {\n\t\t\treq.abort();\n\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\tclearTimeout(reqTimeout);\n\t\t}\n\n\t\tif (request.timeout) {\n\t\t\treq.once('socket', function (socket) {\n\t\t\t\treqTimeout = setTimeout(function () {\n\t\t\t\t\treject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));\n\t\t\t\t\tfinalize();\n\t\t\t\t}, request.timeout);\n\t\t\t});\n\t\t}\n\n\t\treq.on('error', function (err) {\n\t\t\treject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));\n\t\t\tfinalize();\n\t\t});\n\n\t\treq.on('response', function (res) {\n\t\t\tclearTimeout(reqTimeout);\n\n\t\t\tconst headers = createHeadersLenient(res.headers);\n\n\t\t\t// HTTP fetch step 5\n\t\t\tif (fetch.isRedirect(res.statusCode)) {\n\t\t\t\t// HTTP fetch step 5.2\n\t\t\t\tconst location = headers.get('Location');\n\n\t\t\t\t// HTTP fetch step 5.3\n\t\t\t\tconst locationURL = location === null ? null : resolve_url(request.url, location);\n\n\t\t\t\t// HTTP fetch step 5.5\n\t\t\t\tswitch (request.redirect) {\n\t\t\t\t\tcase 'error':\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase 'manual':\n\t\t\t\t\t\t// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.\n\t\t\t\t\t\tif (locationURL !== null) {\n\t\t\t\t\t\t\t// handle corrupted header\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\theaders.set('Location', locationURL);\n\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request\n\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'follow':\n\t\t\t\t\t\t// HTTP-redirect fetch step 2\n\t\t\t\t\t\tif (locationURL === null) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 5\n\t\t\t\t\t\tif (request.counter >= request.follow) {\n\t\t\t\t\t\t\treject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 6 (counter increment)\n\t\t\t\t\t\t// Create a new Request object.\n\t\t\t\t\t\tconst requestOpts = {\n\t\t\t\t\t\t\theaders: new Headers(request.headers),\n\t\t\t\t\t\t\tfollow: request.follow,\n\t\t\t\t\t\t\tcounter: request.counter + 1,\n\t\t\t\t\t\t\tagent: request.agent,\n\t\t\t\t\t\t\tcompress: request.compress,\n\t\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\t\tbody: request.body,\n\t\t\t\t\t\t\tsignal: request.signal,\n\t\t\t\t\t\t\ttimeout: request.timeout,\n\t\t\t\t\t\t\tsize: request.size\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 9\n\t\t\t\t\t\tif (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {\n\t\t\t\t\t\t\treject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 11\n\t\t\t\t\t\tif (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {\n\t\t\t\t\t\t\trequestOpts.method = 'GET';\n\t\t\t\t\t\t\trequestOpts.body = undefined;\n\t\t\t\t\t\t\trequestOpts.headers.delete('content-length');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 15\n\t\t\t\t\t\tresolve(fetch(new Request(locationURL, requestOpts)));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// prepare response\n\t\t\tres.once('end', function () {\n\t\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\t});\n\t\t\tlet body = res.pipe(new PassThrough$1());\n\n\t\t\tconst response_options = {\n\t\t\t\turl: request.url,\n\t\t\t\tstatus: res.statusCode,\n\t\t\t\tstatusText: res.statusMessage,\n\t\t\t\theaders: headers,\n\t\t\t\tsize: request.size,\n\t\t\t\ttimeout: request.timeout,\n\t\t\t\tcounter: request.counter\n\t\t\t};\n\n\t\t\t// HTTP-network fetch step 12.1.1.3\n\t\t\tconst codings = headers.get('Content-Encoding');\n\n\t\t\t// HTTP-network fetch step 12.1.1.4: handle content codings\n\n\t\t\t// in following scenarios we ignore compression support\n\t\t\t// 1. compression support is disabled\n\t\t\t// 2. HEAD request\n\t\t\t// 3. no Content-Encoding header\n\t\t\t// 4. no content response (204)\n\t\t\t// 5. content not modified response (304)\n\t\t\tif (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For Node v6+\n\t\t\t// Be less strict when decoding compressed responses, since sometimes\n\t\t\t// servers send slightly invalid responses that are still accepted\n\t\t\t// by common browsers.\n\t\t\t// Always using Z_SYNC_FLUSH is what cURL does.\n\t\t\tconst zlibOptions = {\n\t\t\t\tflush: zlib.Z_SYNC_FLUSH,\n\t\t\t\tfinishFlush: zlib.Z_SYNC_FLUSH\n\t\t\t};\n\n\t\t\t// for gzip\n\t\t\tif (codings == 'gzip' || codings == 'x-gzip') {\n\t\t\t\tbody = body.pipe(zlib.createGunzip(zlibOptions));\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for deflate\n\t\t\tif (codings == 'deflate' || codings == 'x-deflate') {\n\t\t\t\t// handle the infamous raw deflate response from old servers\n\t\t\t\t// a hack for old IIS and Apache servers\n\t\t\t\tconst raw = res.pipe(new PassThrough$1());\n\t\t\t\traw.once('data', function (chunk) {\n\t\t\t\t\t// see http://stackoverflow.com/questions/37519828\n\t\t\t\t\tif ((chunk[0] & 0x0F) === 0x08) {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflate());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflateRaw());\n\t\t\t\t\t}\n\t\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\t\tresolve(response);\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for br\n\t\t\tif (codings == 'br' && typeof zlib.createBrotliDecompress === 'function') {\n\t\t\t\tbody = body.pipe(zlib.createBrotliDecompress());\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// otherwise, use response as-is\n\t\t\tresponse = new Response(body, response_options);\n\t\t\tresolve(response);\n\t\t});\n\n\t\twriteToStream(req, request);\n\t});\n}\n/**\n * Redirect code matching\n *\n * @param   Number   code  Status code\n * @return  Boolean\n */\nfetch.isRedirect = function (code) {\n\treturn code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n};\n\n// expose Promise\nfetch.Promise = global.Promise;\n\nexport default fetch;\nexport { Headers, Request, Response, FetchError };\n","import * as vscode from \"vscode\";\nimport * as util from \"../util/util\";\nimport * as prompts from \"../util/vscodePrompts\";\nimport * as path from \"path\";\nimport { OPEN_NEW_PROJECT_OPTIONS, ERRORS } from \"../constants\";\nimport * as mpStarterApi from \"../util/mpStarterApi\";\n\nexport async function generateProject(): Promise<void> {\n  try {\n    const mpSupportMatrix = await mpStarterApi.getSupportMatrix();\n    // mpConfigurations is a map of mp version -> mp configuration\n    const mpConfigurations = mpSupportMatrix.configs;\n    const allMpVersions = Object.keys(mpConfigurations);\n\n    const groupId = await prompts.askForGroupID();\n    if (groupId === undefined) {\n      return;\n    }\n\n    const artifactId = await prompts.askForArtifactID();\n    if (artifactId === undefined) {\n      return;\n    }\n\n    const mpVersion = await prompts.askForMPVersion(allMpVersions);\n    if (mpVersion === undefined) {\n      return;\n    }\n\n    // ask user to select one of the servers that are available for the version of mp they selected\n    const mpServer = await prompts.askForMPServer(mpConfigurations[mpVersion].supportedServers);\n    if (mpServer === undefined) {\n      return;\n    }\n\n    // gets support information about which JavaSE versions / microprofile specs are supported by the\n    // users selected mp server / mp version combination\n    const { buildTools, javaSEVersions, mpSpecs } = await mpStarterApi.getSupportedJavaAndSpecs(\n      mpServer,\n      mpVersion\n    );\n\n    const javaSEVersion = await prompts.askForJavaSEVersion(javaSEVersions);\n    if (javaSEVersion === undefined) {\n      return;\n    }\n\n    const buildTool = await prompts.askForBuildTool(buildTools);\n    if (buildTool === undefined) {\n      return;\n    }\n\n    const specDescriptions = mpSupportMatrix.descriptions;\n    const mpSpecifications = await prompts.askForMPSpecifications(mpSpecs, specDescriptions);\n    if (mpSpecifications === undefined) {\n      return;\n    }\n\n    const targetFolder = await prompts.askForTargetFolder(artifactId);\n    if (targetFolder === undefined) {\n      return;\n    }\n\n    const targetDirString = targetFolder.fsPath;\n\n    const projectOptions = {\n      groupId: groupId,\n      artifactId: artifactId,\n      mpVersion: mpVersion,\n      supportedServer: mpServer,\n      javaSEVersion: javaSEVersion,\n      buildTool: buildTool,\n      selectedSpecs: mpSpecifications,\n    };\n\n    const zipName = `${artifactId}.zip`;\n    // location to download the zip file\n    const zipPath = path.join(targetDirString, zipName);\n\n    // show a progress bar as the zip file is being downloaded\n    await vscode.window.withProgress(\n      {\n        location: vscode.ProgressLocation.Notification,\n        title: \"Generating the MicroProfile Starter project...\",\n        cancellable: false,\n      },\n      () => mpStarterApi.downloadMPStarterProjectZip(projectOptions, zipPath)\n    );\n\n    const targetDirFolder = path.join(targetDirString, artifactId);\n\n    try {\n      await util.unzipFile(zipPath, targetDirString, targetDirFolder);\n    } catch (e) {\n      console.error(e);\n      const err = new Error(\"Unable to extract MicroProfile Starter project\");\n      err.name = ERRORS.EXTRACT_PROJECT_ERROR;\n      throw err;\n    }\n\n    // if failed to delete the zip, no need to error out but show a warning to users\n    try {\n      await util.deleteFile(zipPath);\n    } catch (e) {\n      console.error(e);\n      vscode.window.showErrorMessage(`Failed to delete file ${zipName}`);\n    }\n\n    const uriPath = vscode.Uri.file(targetDirFolder);\n    // prompt user whether they want to add project to current workspace or open in a new window\n    const selection = await vscode.window.showInformationMessage(\n      \"MicroProfile Starter project generated.  Add your project to the current workspace or open it in a new window?\",\n      ...[OPEN_NEW_PROJECT_OPTIONS.ADD_CURRENT_WORKSPACE, OPEN_NEW_PROJECT_OPTIONS.OPEN_NEW_WINDOW]\n    );\n    if (selection === OPEN_NEW_PROJECT_OPTIONS.ADD_CURRENT_WORKSPACE) {\n      vscode.workspace.updateWorkspaceFolders(0, 0, { uri: uriPath });\n      vscode.commands.executeCommand(\"workbench.view.explorer\");\n    } else if (selection === OPEN_NEW_PROJECT_OPTIONS.OPEN_NEW_WINDOW) {\n      await vscode.commands.executeCommand(\"vscode.openFolder\", uriPath, true);\n    }\n  } catch (e) {\n    console.error(e);\n    if (e.name === ERRORS.FETCH_ERROR) {\n      vscode.window.showErrorMessage(\n        \"Failed to connect to the MicroProfile Starter. Please check your network connection and try again.\"\n      );\n    } else if (e.name === ERRORS.EXTRACT_PROJECT_ERROR) {\n      vscode.window.showErrorMessage(\"Failed to extract the MicroProfile Starter project\");\n    } else {\n      vscode.window.showErrorMessage(\"Failed to generate a MicroProfile Starter project\");\n    }\n  }\n}\n","export const MP_STARTER_API_ROOT = \"https://start.microprofile.io/api/6\";\n\nexport const MP_VERSION_LABELS: Record<string, string> = {\n  MP40: \"Version 4.0\",\n  MP33: \"Version 3.3\",\n  MP32: \"Version 3.2\",\n  MP30: \"Version 3.0\",\n  MP22: \"Version 2.2\",\n  MP21: \"Version 2.1\",\n  MP20: \"Version 2.0\",\n  MP14: \"Version 1.4\",\n  MP13: \"Version 1.3\",\n  MP12: \"Version 1.2\",\n};\n\nexport const MP_SERVER_LABELS: Record<string, string> = {\n  LIBERTY: \"Open Liberty\",\n  HELIDON: \"Helidon\",\n  PAYARA_MICRO: \"Payara Micro\",\n  THORNTAIL_V2: \"Thorntail Version 2\",\n  KUMULUZEE: \"KumuluzEE\",\n  TOMEE: \"Apache TomEE 8.00-M3\",\n  WILDFLY: \"WildFly\",\n  WILDFLY_SWARM: \"WildFly Swarm\",\n  QUARKUS: \"Quarkus\",\n};\n\nexport const OPEN_NEW_PROJECT_OPTIONS = {\n  ADD_CURRENT_WORKSPACE: \"Add to current workspace\",\n  OPEN_NEW_WINDOW: \"Open in new window\",\n};\n\nexport const EXTENSION_USER_AGENT = \"Visual Studio Code\";\n\nexport const CONFIRM_OPTIONS = {\n  YES: \"Yes\",\n  NO: \"No\",\n};\n\nexport const ERRORS = {\n  FETCH_ERROR: \"FetchError\",\n  EXTRACT_PROJECT_ERROR: \"ExtractProjectError\",\n};\n","import * as vscode from \"vscode\";\nimport { generateProject } from \"./commands/generateProject\";\n\n// this method is called when the extension is activated\n// the extension is activated the very first time the command is executed\nexport function activate(context: vscode.ExtensionContext): void {\n  context.subscriptions.push(\n    vscode.commands.registerCommand(\"extension.microProfileStarter\", generateProject)\n  );\n}\n\n// this method is called when the extension is deactivated\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function deactivate(): void {}\n","import { MP_STARTER_API_ROOT, EXTENSION_USER_AGENT } from \"../constants\";\nimport fetch from \"node-fetch\";\nimport * as util from \"../util/util\";\n\ninterface MPVersionSupport {\n  supportedServers: string[];\n  specs: string[];\n}\n\ninterface SupportMatrix {\n  configs: Record<string, MPVersionSupport>;\n  descriptions: Record<string, string>;\n}\n\nexport async function getSupportMatrix(): Promise<SupportMatrix> {\n  const mpSupportResponse = await fetch(`${MP_STARTER_API_ROOT}/supportMatrix`, {\n    method: \"GET\",\n    headers: {\n      \"User-Agent\": EXTENSION_USER_AGENT,\n    },\n  });\n  if (mpSupportResponse.status >= 400 && mpSupportResponse.status < 600) {\n    throw new Error(`Bad response ${mpSupportResponse.status}: ${mpSupportResponse.statusText}`);\n  }\n\n  return mpSupportResponse.json();\n}\n\ninterface SupportDetails {\n  mpVersion: string;\n  mpSpecs: string[];\n  javaSEVersions: string[];\n  buildTools: string[];\n}\n\nexport async function getSupportedJavaAndSpecs(\n  serverName: string,\n  microprofileVersion: string\n): Promise<SupportDetails> {\n  const serverSupportResponse = await fetch(`${MP_STARTER_API_ROOT}/supportMatrix/servers`, {\n    method: \"GET\",\n    headers: {\n      \"User-Agent\": EXTENSION_USER_AGENT,\n    },\n  });\n  if (serverSupportResponse.status >= 400 && serverSupportResponse.status < 600) {\n    throw new Error(\n      `Bad response ${serverSupportResponse.status}: ${serverSupportResponse.statusText}`\n    );\n  }\n\n  const supportJSON = await serverSupportResponse.json();\n  const serverInformation = supportJSON.configs[serverName];\n  const supportDetails: SupportDetails | undefined = serverInformation.find(\n    (supportRecord: SupportDetails) => supportRecord.mpVersion === microprofileVersion\n  );\n  if (supportDetails === undefined) {\n    throw new Error(\"Unable to find supported MicroProfile specifications and Java versions\");\n  }\n\n  return supportDetails;\n}\n\ninterface StarterProjectOptions {\n  groupId: string;\n  artifactId: string;\n  mpVersion: string;\n  supportedServer: string;\n  javaSEVersion: string;\n  selectedSpecs: string[];\n}\n\nexport async function downloadMPStarterProjectZip(\n  options: StarterProjectOptions,\n  downloadLocation: string\n): Promise<void> {\n  const requestOptions = {\n    url: `${MP_STARTER_API_ROOT}/project`,\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"User-Agent\": EXTENSION_USER_AGENT,\n    },\n    body: JSON.stringify(options),\n  };\n\n  await util.downloadFile(requestOptions, downloadLocation);\n}\n","import * as fs from \"fs\";\nimport fetch from \"node-fetch\";\nimport { pipeline } from \"stream\";\nimport { promisify } from \"util\";\nimport * as admZip from \"adm-zip\";\nimport * as path from \"path\";\nimport * as vscode from \"vscode\";\n\ninterface RequestOptions {\n  url: string;\n}\n\n// Downloads a file using streams to avoid loading entire file into memory\nexport async function downloadFile(\n  requestOptions: RequestOptions,\n  downloadLocation: string\n): Promise<void> {\n  const { url, ...options } = requestOptions;\n  const res = await fetch(url, options);\n  if (res.status >= 400 && res.status < 600) {\n    throw new Error(`Bad response from server ${res.status}: ${res.statusText}`);\n  }\n\n  return new Promise((resolve, reject) => {\n    // create a pipeline that pipes the response to the download location\n    pipeline(res.body, fs.createWriteStream(downloadLocation), err => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nexport const deleteFolder = (parent: string) => {\n  if (fs.existsSync(parent)) {\n    //go through each element in the directory\n    fs.readdirSync(parent).forEach((entry, index) => {\n      const currentPath = path.join(parent, entry);\n      // if it is a file -> delete\n      //if it is directory -> drill down further and repeat\n      if (fs.lstatSync(currentPath).isDirectory()) {\n        deleteFolder(currentPath);\n      } else {\n        fs.unlinkSync(currentPath);\n      }\n    });\n    // finally remove parent directory\n    try {\n      fs.rmdirSync(parent);\n    } catch (e) {\n      vscode.workspace.workspaceFolders?.forEach((entry, index) => {\n        if (entry.name === parent) {\n          vscode.commands.executeCommand(\"workbench.action.removeRootFolder\");\n          fs.rmdirSync(parent);\n        }\n      });\n    }\n  }\n};\n\nexport const deleteFile = promisify(fs.unlink);\n\nexport const exists = promisify(fs.exists);\n\nexport function trimCapitalizeFirstLetter(str: string): string {\n  const newStr = str.trim();\n  return newStr.charAt(0).toUpperCase() + newStr.slice(1);\n}\n\nexport async function unzipFile(\n  zipPath: string,\n  targetDir: string,\n  targetDirFolder: string\n): Promise<void> {\n  const zip = new admZip(zipPath);\n  zip.extractAllTo(targetDir, false);\n  const zipFolderExists = await exists(targetDirFolder);\n  return new Promise((resolve, reject) => {\n    if (zipFolderExists) {\n      resolve();\n    } else {\n      reject(new Error(\"Unable to extract zip folder: \" + targetDirFolder));\n    }\n  });\n}\n\nexport async function validateGroupId(groupId: string): Promise<string | undefined> {\n  // regex referenced from\n  // https://github.com/redhat-developer/vscode-quarkus/blob/master/src/wizards/generateProject/validateInput.ts\n  const re = new RegExp(\"^([a-zA-Z_$][a-zA-Z\\\\d_$]*\\\\.)*[a-zA-Z_$][a-zA-Z\\\\d_$]*$\");\n  if (!re.test(groupId)) {\n    if (!/^[a-zA-Z_$]/.test(groupId)) {\n      return \"Invalid groupId: A valid groupId must start with a character from A to z, or one of the following symbols: _$\";\n    } else if (!/[a-zA-Z\\\\d_$]$/.test(groupId)) {\n      return \"Invalid groupId: A valid groupId must end with a character from A to z, a number, or one of the following symbols: _$\";\n    }\n    return \"Invalid groupId: A valid groupId can only contain characters from A to z, numbers, and the following symbols: ._$\";\n  }\n  return undefined;\n}\n\nexport async function validateArtifactId(artifactId: string): Promise<string | undefined> {\n  // regex referenced from\n  // https://github.com/redhat-developer/vscode-quarkus/blob/master/src/wizards/generateProject/validateInput.ts\n  const re = new RegExp(\"^[a-z][a-z0-9-._]*$\");\n  if (!re.test(artifactId)) {\n    if (!/^[a-z]/.test(artifactId)) {\n      return \"Invalid artifactId: A valid artifactId must start with a character from a-z\";\n    }\n    return \"Invalid artifactId: A valid artifactId can only contain characters from a-z, numbers, and the following symbols: -._\";\n  }\n  return undefined;\n}\n","import * as vscode from \"vscode\";\nimport * as path from \"path\";\nimport { OpenDialogOptions, Uri, window, QuickPickItem } from \"vscode\";\nimport { MP_SERVER_LABELS, MP_VERSION_LABELS, CONFIRM_OPTIONS } from \"../constants\";\nimport {\n  trimCapitalizeFirstLetter,\n  exists,\n  deleteFolder,\n  validateArtifactId,\n  validateGroupId,\n} from \"./util\";\n\nexport async function askForGroupID(): Promise<string | undefined> {\n  return await vscode.window.showInputBox({\n    placeHolder: \"e.g. com.example\",\n    prompt: \"Specify a Group Id for your project.\",\n    value: \"com.example\",\n    ignoreFocusOut: true,\n    validateInput: validateGroupId,\n  });\n}\n\nexport async function askForArtifactID(): Promise<string | undefined> {\n  return await vscode.window.showInputBox({\n    placeHolder: \"demo\",\n    prompt: \"Specify an Artifact Id for your project.\",\n    value: \"demo\",\n    ignoreFocusOut: true,\n    validateInput: validateArtifactId,\n  });\n}\n\nexport async function askForJavaSEVersion(\n  supportedJavaSEVersions: string[]\n): Promise<string | undefined> {\n  return await vscode.window.showQuickPick(supportedJavaSEVersions, {\n    ignoreFocusOut: true,\n    placeHolder: \"Select a Java SE version.\",\n  });\n}\n\nexport async function askForBuildTool(supportedBuildTools: string[]): Promise<string | undefined> {\n  const supportedBuildToolsOptions: string[] = [];\n  for (const buildTool of supportedBuildTools) {\n    const lower = buildTool.toLowerCase();\n    const formattedBuildTool = lower.charAt(0).toUpperCase() + lower.substring(1);\n    supportedBuildToolsOptions.push(formattedBuildTool);\n  }\n  const buildToolQuickPickResult = await vscode.window.showQuickPick(supportedBuildToolsOptions, {\n    ignoreFocusOut: true,\n    placeHolder: \"Select a build tool.\",\n  });\n  if (buildToolQuickPickResult != null) {\n    return buildToolQuickPickResult.toUpperCase();\n  }\n  return undefined;\n}\n\nexport async function askForMPVersion(mpVersions: string[]): Promise<string | undefined> {\n  interface MPVersionOption extends QuickPickItem {\n    label: string; // label is the long-name that is displayed in vscode\n    version: string; // version is the short-name that is used internally by the microprofile starter api\n  }\n\n  const mpVersionOptions: MPVersionOption[] = [];\n  for (const mpVersion of mpVersions) {\n    // if we have a label defined for the given MP version short-name add it to the options array\n    if (MP_VERSION_LABELS[mpVersion] != null) {\n      mpVersionOptions.push({\n        label: MP_VERSION_LABELS[mpVersion],\n        version: mpVersion,\n      });\n    }\n  }\n\n  const mpVersionQuickPickResult = await vscode.window.showQuickPick(mpVersionOptions, {\n    ignoreFocusOut: true,\n    placeHolder: \"Select a MicroProfile version.\",\n  });\n\n  if (mpVersionQuickPickResult != null) {\n    return mpVersionQuickPickResult.version;\n  }\n\n  return undefined;\n}\n\nexport async function askForMPServer(mpServers: string[]): Promise<string | undefined> {\n  interface MPServerOption extends QuickPickItem {\n    label: string; // label is the long-name that is displayed in vscode\n    server: string; // server is the short-name that is used internally by the microprofile starter api\n  }\n\n  const mpServerOptions: MPServerOption[] = [];\n  for (const mpServer of mpServers) {\n    // if we have a server label for the given mp server short-name add it to the options array\n    if (MP_SERVER_LABELS[mpServer] != null) {\n      mpServerOptions.push({\n        label: MP_SERVER_LABELS[mpServer],\n        server: mpServer,\n      });\n    }\n  }\n\n  const mpVersionQuickPickResult = await vscode.window.showQuickPick(mpServerOptions, {\n    ignoreFocusOut: true,\n    placeHolder: \"Select a MicroProfile server.\",\n  });\n\n  if (mpVersionQuickPickResult != null) {\n    return mpVersionQuickPickResult.server;\n  }\n  return undefined;\n}\n\nexport async function askForMPSpecifications(\n  specs: string[],\n  specDescriptions: Record<string, string>\n): Promise<Array<string> | undefined> {\n  interface MPSpecOption extends QuickPickItem {\n    spec: string; // spec is the short-name used internally my microprofile starter api\n    label: string; // name of mp spec\n    detail: string; // description of mp spec\n  }\n\n  const mpSpecOptions: MPSpecOption[] = specs.map(spec => {\n    const fullDescription = specDescriptions[spec];\n    const [name, desc] = fullDescription.split(\"-\");\n    return {\n      spec: spec,\n      label: name,\n      detail: trimCapitalizeFirstLetter(desc),\n    };\n  });\n\n  const specResults: MPSpecOption[] | undefined = await vscode.window.showQuickPick(mpSpecOptions, {\n    ignoreFocusOut: true,\n    canPickMany: true,\n    placeHolder: \"Select MicroProfile specifications.\",\n  });\n\n  if (specResults != null) {\n    return specResults.map(result => result.spec);\n  }\n  return undefined;\n}\n\nexport async function askForFolder(customOptions: OpenDialogOptions): Promise<Uri | undefined> {\n  const options: OpenDialogOptions = {\n    canSelectFiles: false,\n    canSelectFolders: true,\n    canSelectMany: false,\n  };\n  const result = await window.showOpenDialog(Object.assign(options, customOptions));\n\n  if (result && result.length > 0) {\n    return result[0];\n  }\n\n  return undefined;\n}\n\nexport async function askForTargetFolder(artifactId: string): Promise<Uri | undefined> {\n  const customOptions: OpenDialogOptions = {\n    openLabel: \"Generate into this folder\",\n  };\n\n  const targetFolder = await askForFolder(customOptions);\n\n  if (targetFolder && (await exists(path.join(targetFolder.fsPath, artifactId)))) {\n    const selection = await askConfirmation(\n      `Folder ${artifactId} already exists inside the ${targetFolder.fsPath} folder. The ${artifactId} folder will be deleted and replaced with the generated MicroProfile Starter project. Are you sure you want to generate into this folder?`\n    );\n    if (selection === CONFIRM_OPTIONS.YES) {\n      // delete the existing folder.\n      try {\n        deleteFolder(path.join(targetFolder.fsPath, artifactId));\n      } catch (e) {\n        //the folder is in use\n        vscode.window.showErrorMessage(\n          `Failed to delete folder ${targetFolder.fsPath} because it is being used by another process. Failed to generate a MicroProfile Starter project.`\n        );\n      }\n    } else if (selection === CONFIRM_OPTIONS.NO) {\n      return await askForTargetFolder(artifactId);\n    }\n  }\n\n  return targetFolder;\n}\n\nexport async function askConfirmation(message: string): Promise<string | undefined> {\n  return await vscode.window.showWarningMessage(\n    message,\n    ...[CONFIRM_OPTIONS.YES, CONFIRM_OPTIONS.NO]\n  );\n}\n","module.exports = require(\"fs\");;","module.exports = require(\"path\");;","module.exports = require(\"stream\");;","module.exports = require(\"util\");;","module.exports = require(\"vscode\");;","module.exports = require(\"zlib\");;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(112);\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};"],"sourceRoot":""}