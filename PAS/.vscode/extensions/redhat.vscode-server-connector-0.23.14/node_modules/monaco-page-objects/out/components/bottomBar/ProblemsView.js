"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MarkerType = exports.Marker = exports.ProblemsView = void 0;
const __1 = require("../..");
const AbstractElement_1 = require("../AbstractElement");
const ElementWithContextMenu_1 = require("../ElementWithContextMenu");
/**
 * Problems view in the bottom panel
 */
class ProblemsView extends AbstractElement_1.AbstractElement {
    constructor(panel = new __1.BottomBarPanel()) {
        super(ProblemsView.locators.ProblemsView.constructor, panel);
    }
    /**
     * Set the filter using the input box on the problems view
     * @param pattern filter to use, prefferably a glob pattern
     * @returns Promise resolving when the filter pattern is filled in
     */
    setFilter(pattern) {
        return __awaiter(this, void 0, void 0, function* () {
            const filterField = yield this.clearFilter();
            yield filterField.sendKeys(pattern);
        });
    }
    /**
     * Clear all filters
     * @returns Promise resolving to the filter field WebElement
     */
    clearFilter() {
        return __awaiter(this, void 0, void 0, function* () {
            const filterField = yield this.enclosingItem.findElement(ProblemsView.locators.BottomBarPanel.actions)
                .findElement(ProblemsView.locators.ProblemsView.markersFilter)
                .findElement(ProblemsView.locators.ProblemsView.input);
            yield filterField.clear();
            return filterField;
        });
    }
    /**
     * Collapse all collapsible markers in the problems view
     * @returns Promise resolving when the collapse all button is pressed
     */
    collapseAll() {
        return __awaiter(this, void 0, void 0, function* () {
            const button = yield this.enclosingItem.findElement(ProblemsView.locators.BottomBarPanel.actions)
                .findElement(ProblemsView.locators.ProblemsView.collapseAll);
            yield button.click();
        });
    }
    /**
     * Get all markers from the problems view with the given type.
     * To get all markers regardless of type, use MarkerType.Any
     * @param type type of markers to retrieve
     * @returns Promise resolving to array of Marker objects
     */
    getAllMarkers(type) {
        return __awaiter(this, void 0, void 0, function* () {
            const markers = [];
            const elements = yield this.findElements(ProblemsView.locators.ProblemsView.markerRow);
            for (const element of elements) {
                let marker;
                marker = yield new Marker(element, this).wait();
                if (type === MarkerType.Any || type === (yield marker.getType())) {
                    markers.push(marker);
                }
            }
            return markers;
        });
    }
}
exports.ProblemsView = ProblemsView;
/**
 * Page object for marker in problems view
 */
class Marker extends ElementWithContextMenu_1.ElementWithContexMenu {
    constructor(element, view) {
        super(element, view);
    }
    /**
     * Get the type of the marker
     * Possible types are: File, Error, Warning
     * @returns Promise resolving to a MarkerType
     */
    getType() {
        return __awaiter(this, void 0, void 0, function* () {
            const twist = yield this.findElement(ProblemsView.locators.ProblemsView.markerTwistie);
            if ((yield twist.getAttribute('class')).indexOf('collapsible') > -1) {
                return MarkerType.File;
            }
            const text = yield this.getText();
            if (text.startsWith('Error')) {
                return MarkerType.Error;
            }
            else {
                return MarkerType.Warning;
            }
        });
    }
    /**
     * Get the full text of the marker
     * @returns Promise resolving to marker text
     */
    getText() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.getAttribute(ProblemsView.locators.ProblemsView.rowLabel);
        });
    }
    /**
     * Expand/Collapse the marker if possible
     * @param expand true to expand, false to collapse
     * @returns Promise resolving when the expand/collapse twistie is clicked
     */
    toggleExpand(expand) {
        return __awaiter(this, void 0, void 0, function* () {
            if ((yield this.getType()) === MarkerType.File) {
                const klass = yield this.findElement(ProblemsView.locators.ProblemsView.markerTwistie).getAttribute('class');
                if ((klass.indexOf('collapsed') > -1) === expand) {
                    yield this.click();
                }
            }
        });
    }
}
exports.Marker = Marker;
/**
 * Possible types of markers
 *  - File = expandable item representing a file
 *  - Error = an error marker
 *  - Warning = a warning marker
 *  - Any = any of the above
 */
var MarkerType;
(function (MarkerType) {
    MarkerType["File"] = "file";
    MarkerType["Error"] = "error";
    MarkerType["Warning"] = "warning";
    MarkerType["Any"] = "any";
})(MarkerType = exports.MarkerType || (exports.MarkerType = {}));
//# sourceMappingURL=ProblemsView.js.map