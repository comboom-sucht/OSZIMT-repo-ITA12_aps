"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExtensionsViewSection = void 0;
const ViewSection_1 = require("../ViewSection");
const ExtensionsViewItem_1 = require("./ExtensionsViewItem");
const selenium_webdriver_1 = require("selenium-webdriver");
/**
 * Categories of extensions to search for
 */
var ExtensionCategory;
(function (ExtensionCategory) {
    ExtensionCategory["Installed"] = "@installed";
    ExtensionCategory["Enabled"] = "@enabled";
    ExtensionCategory["Disabled"] = "@disabled";
    ExtensionCategory["Outdated"] = "@outdated";
    ExtensionCategory["Recommended"] = "@recommended";
})(ExtensionCategory || (ExtensionCategory = {}));
/**
 * View section containing extensions
 */
class ExtensionsViewSection extends ViewSection_1.ViewSection {
    getVisibleItems() {
        return __awaiter(this, void 0, void 0, function* () {
            const extensionTable = yield this.findElement(ExtensionsViewSection.locators.ExtensionsViewSection.items);
            const extensionRows = yield extensionTable.findElements(ExtensionsViewSection.locators.ExtensionsViewSection.itemRow);
            return Promise.all(extensionRows.map((row) => __awaiter(this, void 0, void 0, function* () { return new ExtensionsViewItem_1.ExtensionsViewItem(row, this).wait(); })));
        });
    }
    /**
     * Search for an extension by title. This utilizes the search bar
     * in the Extensions view, which switches the perspective to the
     * section representing the chosen category and temporarily hides all other sections.
     * If you wish to continue working with the initial view section
     * (i.e. Enabled), use the clearSearch method to reset it back to default
     *
     * @param title title to search for in '@category name' format,
     * e.g '@installed extension'. If no @category is present, marketplace will be searched
     *
     * @returns Promise resolving to ExtensionsViewItem if such item exists, undefined otherwise
     */
    findItem(title) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.clearSearch();
            const progress = yield this.enclosingItem.findElement(ExtensionsViewSection.locators.ViewContent.progress);
            const searchField = yield this.enclosingItem.findElement(ExtensionsViewSection.locators.ExtensionsViewSection.searchBox);
            yield searchField.sendKeys(title);
            yield this.getDriver().wait(selenium_webdriver_1.until.elementIsVisible(progress));
            yield this.getDriver().wait(selenium_webdriver_1.until.elementIsNotVisible(progress));
            const parent = this.enclosingItem;
            let sectionTitle = this.getSectionForCategory(title);
            const section = yield parent.getSection(sectionTitle);
            const titleParts = title.split(' ');
            if (titleParts[0].startsWith('@')) {
                title = titleParts.slice(1).join(' ');
            }
            const extensions = yield section.getVisibleItems();
            for (const extension of extensions) {
                if ((yield extension.getTitle()) === title) {
                    return extension;
                }
            }
            return undefined;
        });
    }
    /**
     * Clears the search bar on top of the view
     * @returns Promise resolving when the search box is cleared
     */
    clearSearch() {
        return __awaiter(this, void 0, void 0, function* () {
            const progress = yield this.enclosingItem.findElement(ExtensionsViewSection.locators.ViewContent.progress);
            const searchField = yield this.enclosingItem.findElement(ExtensionsViewSection.locators.ExtensionsViewSection.searchBox);
            const textField = yield this.enclosingItem.findElement(ExtensionsViewSection.locators.ExtensionsViewSection.textContainer);
            try {
                yield textField.findElement(ExtensionsViewSection.locators.ExtensionsViewSection.textField);
                yield searchField.sendKeys(selenium_webdriver_1.Key.chord(ExtensionsViewItem_1.ExtensionsViewItem.ctlKey, 'a'), selenium_webdriver_1.Key.BACK_SPACE);
                yield this.getDriver().wait(selenium_webdriver_1.until.elementIsVisible(progress));
                yield this.getDriver().wait(selenium_webdriver_1.until.elementIsNotVisible(progress));
            }
            catch (err) {
                // do nothing, the text field is empty
            }
        });
    }
    /**
     * Find and open an extension item
     * @param title title of the extension
     * @returns Promise resolving when the item is clicked
     */
    openItem(title) {
        return __awaiter(this, void 0, void 0, function* () {
            const item = yield this.findItem(title);
            if (item) {
                yield item.click();
            }
            return [];
        });
    }
    getSectionForCategory(title) {
        const category = title.split(' ')[0].toLowerCase();
        switch (category) {
            case ExtensionCategory.Disabled:
                return 'Disabled';
            case ExtensionCategory.Enabled:
                return 'Enabled';
            case ExtensionCategory.Installed:
                return 'Installed';
            case ExtensionCategory.Outdated:
                return 'Outdated';
            case ExtensionCategory.Recommended:
                return 'Other Recommendations';
            default:
                return 'Marketplace';
        }
    }
}
exports.ExtensionsViewSection = ExtensionsViewSection;
//# sourceMappingURL=ExtensionsViewSection.js.map