"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ViewContent = void 0;
const AbstractElement_1 = require("../AbstractElement");
const __1 = require("../..");
const DefaultTreeSection_1 = require("./tree/default/DefaultTreeSection");
const CustomTreeSection_1 = require("./tree/custom/CustomTreeSection");
const ExtensionsViewSection_1 = require("./extensions/ExtensionsViewSection");
/**
 * Page object representing the view container of a side bar view
 */
class ViewContent extends AbstractElement_1.AbstractElement {
    constructor(view = new __1.SideBarView()) {
        super(ViewContent.locators.ViewContent.constructor, view);
    }
    /**
     * Finds whether a progress bar is active at the top of the view
     * @returns Promise resolving to true/false
     */
    hasProgress() {
        return __awaiter(this, void 0, void 0, function* () {
            const progress = yield this.findElement(ViewContent.locators.ViewContent.progress);
            const hidden = yield progress.getAttribute('aria-hidden');
            if (hidden === 'true') {
                return false;
            }
            return true;
        });
    }
    /**
     * Retrieves a collapsible view content section by its title
     * @param title Title of the section
     * @returns Promise resolving to ViewSection object
     */
    getSection(title) {
        return __awaiter(this, void 0, void 0, function* () {
            const elements = yield this.findElements(ViewContent.locators.ViewContent.section);
            let panel;
            for (const element of elements) {
                const currentTitle = yield element.findElement(ViewContent.locators.ViewContent.sectionTitle);
                if ((yield currentTitle.getAttribute(ViewContent.locators.ViewContent.sectionText)) === title) {
                    panel = element;
                    break;
                }
            }
            if (!panel) {
                throw new Error(`No section with title '${title}' found`);
            }
            return yield this.createSection(panel);
        });
    }
    /**
     * Retrieves all the collapsible view content sections
     * @returns Promise resolving to array of ViewSection objects
     */
    getSections() {
        return __awaiter(this, void 0, void 0, function* () {
            const sections = [];
            const elements = yield this.findElements(ViewContent.locators.ViewContent.section);
            for (const element of elements) {
                let section = yield this.createSection(element);
                sections.push(yield section.wait());
            }
            return sections;
        });
    }
    createSection(panel) {
        return __awaiter(this, void 0, void 0, function* () {
            let section = new DefaultTreeSection_1.DefaultTreeSection(panel, this);
            try {
                yield section.findElement(ViewContent.locators.ViewContent.defaultView);
            }
            catch (err) {
                try {
                    yield section.findElement(ViewContent.locators.ViewContent.extensionsView);
                    section = new ExtensionsViewSection_1.ExtensionsViewSection(panel, this);
                }
                catch (err) {
                    section = new CustomTreeSection_1.CustomTreeSection(panel, this);
                }
            }
            return section;
        });
    }
}
exports.ViewContent = ViewContent;
//# sourceMappingURL=ViewContent.js.map