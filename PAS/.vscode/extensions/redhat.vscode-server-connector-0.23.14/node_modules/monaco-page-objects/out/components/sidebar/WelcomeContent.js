"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WelcomeContentSection = exports.WelcomeContentButton = void 0;
const AbstractElement_1 = require("../AbstractElement");
/**
 * A button that appears in the welcome content and can be clicked to execute a command.
 *
 * To execute the command bound to this button simply run: `await button.click();`.
 */
class WelcomeContentButton extends AbstractElement_1.AbstractElement {
    /**
     * @param panel  The panel containing the button in the welcome section
     * @param welcomeSection  The enclosing welcome section
     */
    constructor(panel, welcomeSection) {
        super(panel, welcomeSection);
    }
    /** Return the title displayed on this button */
    getTitle() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getText();
        });
    }
}
exports.WelcomeContentButton = WelcomeContentButton;
/**
 * A section in an empty custom view, see:
 * https://code.visualstudio.com/api/extension-guides/tree-view#welcome-content
 *
 * The welcome section contains two types of elements: text entries and buttons that can be bound to commands.
 * The text sections can be accessed via [[getTextSections]], the buttons on the
 * other hand via [[getButtons]].
 * This however looses the information of the order of the buttons and lines
 * with respect to each other. This can be remedied by using [[getContents]],
 * which returns both in the order that they are found (at the expense, that you
 * now must use typechecks to find out what you got).
 */
class WelcomeContentSection extends AbstractElement_1.AbstractElement {
    /**
     * @param panel  The panel containing the welcome content.
     * @param parent  The webelement in which the welcome content is embedded.
     */
    constructor(panel, parent) {
        super(panel, parent);
    }
    /**
     * Combination of [[getButtons]] and [[getTextSections]]: returns all entries in the welcome view in the order that they appear.
     */
    getContents() {
        return __awaiter(this, void 0, void 0, function* () {
            const elements = yield this.findElements(WelcomeContentSection.locators.WelcomeContent.buttonOrText);
            return Promise.all(elements.map((e) => __awaiter(this, void 0, void 0, function* () {
                const tagName = yield e.getTagName();
                if (tagName === "p") {
                    return e.getText();
                }
                else {
                    return new WelcomeContentButton(e, this);
                }
            })));
        });
    }
    /** Finds all buttons in the welcome content */
    getButtons() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.findElements(WelcomeContentSection.locators.WelcomeContent.button)).map((elem) => new WelcomeContentButton(elem, this));
        });
    }
    /**
     * Finds all text entries in the welcome content and returns each line as an
     * element in an array.
     */
    getTextSections() {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.all((yield this.findElements(WelcomeContentSection.locators.WelcomeContent.text)).map((elem) => elem.getText()));
        });
    }
}
exports.WelcomeContentSection = WelcomeContentSection;
//# sourceMappingURL=WelcomeContent.js.map