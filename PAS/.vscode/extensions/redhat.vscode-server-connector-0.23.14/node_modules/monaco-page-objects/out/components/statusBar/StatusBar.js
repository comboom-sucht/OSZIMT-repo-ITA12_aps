"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StatusBar = void 0;
const selenium_webdriver_1 = require("selenium-webdriver");
const AbstractElement_1 = require("../AbstractElement");
const NotificationsCenter_1 = require("../workbench/NotificationsCenter");
/**
 * Page object for the status bar at the bottom
 */
class StatusBar extends AbstractElement_1.AbstractElement {
    constructor() {
        super(StatusBar.locators.StatusBar.constructor, StatusBar.locators.Workbench.constructor);
    }
    /**
     * Retrieve all status bar items currently displayed
     * @returns Promise resolving to an array of WebElement
     */
    getItems() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.findElements(StatusBar.locators.StatusBar.item);
        });
    }
    /**
     * Find status bar item by title (the one that pops up when you hover the item)
     * @param title title of the item
     * @returns Promise resolving to a WebElement if item is found, to undefined otherwise
     */
    getItem(title) {
        return __awaiter(this, void 0, void 0, function* () {
            const items = yield this.getItems();
            for (const item of items) {
                if ((yield item.getAttribute('title')) === title) {
                    return item;
                }
            }
            return undefined;
        });
    }
    /**
     * Open the notifications center
     * @returns Promise resolving to NotificationsCenter object
     */
    openNotificationsCenter() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.toggleNotificationsCentre(true);
            return new NotificationsCenter_1.NotificationsCenter();
        });
    }
    /**
     * Close the notifications center
     * @returns Promise resolving when the notifications center is closed
     */
    closeNotificationsCenter() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.toggleNotificationsCentre(false);
        });
    }
    /**
     * Open the language selection quick pick
     * Only works with an open editor
     * @returns Promise resolving when the language selection is opened
     */
    openLanguageSelection() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.findElement(StatusBar.locators.StatusBar.language).click();
        });
    }
    /**
     * Get the current language label text
     * Only works with an open editor
     * @returns Promise resolving to string representation of current language
     */
    getCurrentLanguage() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getPartText(StatusBar.locators.StatusBar.language);
        });
    }
    /**
     * Open the quick pick for line endings selection
     * Only works with an open editor
     * @returns Promise resolving when the line ending selection is opened
     */
    openLineEndingSelection() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.findElement(StatusBar.locators.StatusBar.lines).click();
        });
    }
    /**
     * Get the currently selected line ending as text
     * Only works with an open editor
     * @returns Promise resolving to string representation of current line ending
     */
    getCurrentLineEnding() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getPartText(StatusBar.locators.StatusBar.lines);
        });
    }
    /**
     * Open the encoding selection quick pick
     * Only works with an open editor
     * @returns Promise resolving when the encoding selection is opened
     */
    openEncodingSelection() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.findElement(StatusBar.locators.StatusBar.encoding).click();
        });
    }
    /**
     * Get the name of the current encoding as text
     * Only works with an open editor
     * @returns Promise resolving to string representation of current encoding
     */
    getCurrentEncoding() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getPartText(StatusBar.locators.StatusBar.encoding);
        });
    }
    /**
     * Open the indentation selection quick pick
     * Only works with an open editor
     * @returns Promise resolving when the indentation selection is opened
     */
    openIndentationSelection() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.findElement(StatusBar.locators.StatusBar.indent).click();
        });
    }
    /**
     * Get the current indentation option label as text
     * Only works with an open editor
     * @returns Promise resolving to string representation of current indentation
     */
    getCurrentIndentation() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getPartText(StatusBar.locators.StatusBar.indent);
        });
    }
    /**
     * Open the line selection input box
     * Only works with an open editor
     * @returns Promise resolving when the line selection is opened
     */
    openLineSelection() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.findElement(StatusBar.locators.StatusBar.selection).click();
        });
    }
    /**
     * Get the current editor coordinates as text
     * Only works with an open editor
     * @returns Promise resolving to string representation of current position in the editor
     */
    getCurrentPosition() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getPartText(StatusBar.locators.StatusBar.selection);
        });
    }
    /**
     * Open/Close notification centre
     * @param open true to open, false to close
     */
    toggleNotificationsCentre(open) {
        return __awaiter(this, void 0, void 0, function* () {
            let visible = false;
            try {
                const klass = yield this.enclosingItem.findElement(StatusBar.locators.StatusBar.notifications).getAttribute('class');
                visible = klass.indexOf('visible') > -1;
            }
            catch (err) {
                // element doesn't exist until the button is first clicked
            }
            if (visible !== open) {
                yield this.findElement(StatusBar.locators.StatusBar.bell).click();
            }
        });
    }
    getPartText(locator) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.findElement(locator).findElement(selenium_webdriver_1.By.css('a')).getAttribute('innerHTML');
        });
    }
}
exports.StatusBar = StatusBar;
//# sourceMappingURL=StatusBar.js.map