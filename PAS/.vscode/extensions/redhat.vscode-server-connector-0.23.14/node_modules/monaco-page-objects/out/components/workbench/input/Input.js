"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuickPickItem = exports.Input = void 0;
const AbstractElement_1 = require("../../AbstractElement");
const selenium_webdriver_1 = require("selenium-webdriver");
const __1 = require("../../..");
const clipboard = require("clipboardy");
/**
 * Abstract page object for input fields
 */
class Input extends AbstractElement_1.AbstractElement {
    /**
     * Get current text of the input field
     * @returns Promise resolving to text of the input field
     */
    getText() {
        return __awaiter(this, void 0, void 0, function* () {
            const input = yield this.findElement(Input.locators.Input.inputBox)
                .findElement(Input.locators.Input.input);
            return input.getAttribute('value');
        });
    }
    /**
     * Set (by selecting all and typing) text in the input field
     * @param text text to set into the input field
     * @returns Promise resolving when the text is typed in
     */
    setText(text) {
        return __awaiter(this, void 0, void 0, function* () {
            const input = yield this.findElement(Input.locators.Input.inputBox)
                .findElement(Input.locators.Input.input);
            yield this.clear();
            yield new Promise(res => setTimeout(res, 200));
            if ((yield this.getText()).length > 0) {
                yield input.sendKeys(selenium_webdriver_1.Key.END, selenium_webdriver_1.Key.chord(selenium_webdriver_1.Key.SHIFT, selenium_webdriver_1.Key.HOME));
            }
            yield input.sendKeys(text);
            // fallback to clipboard if the text gets malformed
            if ((yield this.getText()) !== text) {
                yield clipboard.write(text);
                yield input.sendKeys(selenium_webdriver_1.Key.END, selenium_webdriver_1.Key.chord(selenium_webdriver_1.Key.SHIFT, selenium_webdriver_1.Key.HOME));
                yield input.sendKeys(selenium_webdriver_1.Key.chord(Input.ctlKey, 'v'));
                yield clipboard.write('');
            }
        });
    }
    /**
     * Get the placeholder text for the input field
     * @returns Promise resolving to input placeholder
     */
    getPlaceHolder() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.findElement(Input.locators.Input.inputBox)
                .findElement(Input.locators.Input.input).getAttribute('placeholder');
        });
    }
    /**
     * Confirm the input field by pressing Enter
     * @returns Promise resolving when the input is confirmed
     */
    confirm() {
        return __awaiter(this, void 0, void 0, function* () {
            const input = yield this.findElement(Input.locators.Input.inputBox)
                .findElement(Input.locators.Input.input);
            yield input.click();
            yield input.sendKeys(selenium_webdriver_1.Key.ENTER);
        });
    }
    /**
     * Cancel the input field by pressing Escape
     * @returns Promise resolving when the input is cancelled
     */
    cancel() {
        return __awaiter(this, void 0, void 0, function* () {
            const input = yield this.findElement(Input.locators.Input.inputBox)
                .findElement(Input.locators.Input.input);
            yield input.sendKeys(selenium_webdriver_1.Key.ESCAPE);
        });
    }
    /**
     * Clear the inpur field
     * @returns Promise resolving when the field is cleared
     */
    clear() {
        return __awaiter(this, void 0, void 0, function* () {
            const input = yield this.findElement(Input.locators.Input.inputBox)
                .findElement(Input.locators.Input.input);
            // VS Code 1.40 breaks the default clear method, use select all + back space instead
            yield input.sendKeys(selenium_webdriver_1.Key.END, selenium_webdriver_1.Key.chord(selenium_webdriver_1.Key.SHIFT, selenium_webdriver_1.Key.HOME), selenium_webdriver_1.Key.BACK_SPACE);
            if ((yield input.getAttribute('value')).length > 0) {
                yield input.sendKeys(selenium_webdriver_1.Key.END, selenium_webdriver_1.Key.chord(selenium_webdriver_1.Key.SHIFT, selenium_webdriver_1.Key.HOME), selenium_webdriver_1.Key.BACK_SPACE);
            }
        });
    }
    /**
     * Select (click) a quick pick option. Will scroll through the quick picks to find the item.
     * Search for the item can be done by its text, or index in the quick pick menu.
     * Note that scrolling does not affect the item's index, but it will
     * replace some items in the DOM (thus they become unreachable)
     *
     * @param indexOrText index (number) or text (string) of the item to search by
     * @returns Promise resolving when the given quick pick is selected
     */
    selectQuickPick(indexOrText) {
        return __awaiter(this, void 0, void 0, function* () {
            const pick = yield this.findQuickPick(indexOrText);
            if (pick) {
                yield pick.select();
            }
            else {
                yield this.resetPosition();
            }
        });
    }
    /**
     * Select/Deselect all quick picks using the 'select all' checkbox
     * If multiple selection is disabled on the input box, no action is performed
     *
     * @param state true to select all, false to deselect all
     * @returns Promise resolving when all quick picks have been toggled to desired state
     */
    toggleAllQuickPicks(state) {
        return __awaiter(this, void 0, void 0, function* () {
            const checkboxes = yield this.findElements(Input.locators.Input.quickPickSelectAll);
            if (checkboxes.length < 0) {
                return;
            }
            if (!(yield checkboxes[0].isSelected())) {
                yield checkboxes[0].click();
            }
            if (state === false) {
                yield checkboxes[0].click();
            }
        });
    }
    /**
     * Scroll through the quick picks to find an item by the name or index
     * @param indexOrText index (number) or text (string) of the item to search by
     * @returns Promise resolvnig to QuickPickItem if found, to undefined otherwise
     */
    findQuickPick(indexOrText) {
        return __awaiter(this, void 0, void 0, function* () {
            const input = yield this.findElement(Input.locators.Input.inputBox)
                .findElement(Input.locators.Input.input);
            const first = yield this.findElements(Input.locators.Input.quickPickPosition(1));
            if (first.length < 1) {
                yield this.resetPosition();
            }
            let endReached = false;
            while (!endReached) {
                const picks = yield this.getQuickPicks();
                for (const pick of picks) {
                    const lastRow = yield this.findElements(Input.locators.DefaultTreeSection.lastRow);
                    if (lastRow.length > 0) {
                        endReached = true;
                    }
                    else if ((yield pick.getAttribute('aria-posinset')) === (yield pick.getAttribute('aria-setsize'))) {
                        endReached = true;
                    }
                    if (typeof indexOrText === 'string') {
                        const text = yield pick.getLabel();
                        if (text.indexOf(indexOrText) > -1) {
                            return pick;
                        }
                    }
                    else if (indexOrText === pick.getIndex()) {
                        return pick;
                    }
                }
                if (!endReached) {
                    yield input.sendKeys(selenium_webdriver_1.Key.PAGE_DOWN);
                }
            }
            return undefined;
        });
    }
    /**
     * Retrieve the title of an input box if it has one
     * @returns Promise resolving to title if it exists, to undefined otherwise
     */
    getTitle() {
        return __awaiter(this, void 0, void 0, function* () {
            const titleBar = yield this.findElements(Input.locators.Input.titleBar);
            if (titleBar.length > 0 && (yield titleBar[0].isDisplayed())) {
                return (yield titleBar[0].findElement(Input.locators.Input.title)).getText();
            }
        });
    }
    /**
     * Click on the back button if it exists
     * @returns Promise resolving to true if a button was clicked, to false otherwise
     */
    back() {
        return __awaiter(this, void 0, void 0, function* () {
            const titleBar = yield this.findElements(Input.locators.Input.titleBar);
            if (titleBar.length > 0 && (yield titleBar[0].isDisplayed())) {
                const backBtn = yield titleBar[0].findElements(Input.locators.Input.backButton);
                if (backBtn.length > 0 && (yield backBtn[0].isEnabled())) {
                    yield backBtn[0].click();
                    return true;
                }
            }
            return false;
        });
    }
    resetPosition() {
        return __awaiter(this, void 0, void 0, function* () {
            const text = yield this.getText();
            yield this.clear();
            yield this.setText(text);
        });
    }
}
exports.Input = Input;
/**
 * Page object representing a quick pick option in the input box
 */
class QuickPickItem extends AbstractElement_1.AbstractElement {
    constructor(index, input) {
        let locator = Input.locators.Input.quickPickIndex(index);
        if (input instanceof __1.QuickOpenBox) {
            locator = Input.locators.Input.quickPickPosition(index);
        }
        super(locator, input);
        this.index = index;
    }
    /**
     * Get the label of the quick pick item
     */
    getLabel() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.findElement(Input.locators.Input.quickPickLabel).getText();
        });
    }
    /**
     * Get the description of the quick pick item
     */
    getDescription() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return this.findElement(Input.locators.Input.quickPickDescription).getText();
            }
            catch (err) {
                return undefined;
            }
        });
    }
    /**
     * Get the index of the quick pick item
     */
    getIndex() {
        return this.index;
    }
    /**
     * Select (click) the quick pick item
     * @returns Promise resolving when the item has been clicked
     */
    select() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.click();
        });
    }
}
exports.QuickPickItem = QuickPickItem;
//# sourceMappingURL=Input.js.map