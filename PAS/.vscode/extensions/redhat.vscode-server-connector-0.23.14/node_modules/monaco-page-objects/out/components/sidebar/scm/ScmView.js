"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MoreAction = exports.ScmChange = exports.ScmProvider = exports.ScmView = void 0;
const SideBarView_1 = require("../SideBarView");
const selenium_webdriver_1 = require("selenium-webdriver");
const AbstractElement_1 = require("../../AbstractElement");
const __1 = require("../../..");
const ElementWithContextMenu_1 = require("../../ElementWithContextMenu");
/**
 * Page object representing the Source Control view
 */
class ScmView extends SideBarView_1.SideBarView {
    /**
     * Get SCM provider (repository) by title
     * @param title name of the repository
     * @returns promise resolving to ScmProvider object
     */
    getProvider(title) {
        return __awaiter(this, void 0, void 0, function* () {
            const providers = yield this.getProviders();
            if (!title || providers.length === 1) {
                return providers[0];
            }
            const names = yield Promise.all(providers.map((item) => __awaiter(this, void 0, void 0, function* () { return item.getTitle(); })));
            const index = names.findIndex(name => name === title);
            return index > -1 ? providers[index] : undefined;
        });
    }
    /**
     * Get all SCM providers
     * @returns promise resolving to ScmProvider array
     */
    getProviders() {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = yield this.findElements(ScmView.locators.ScmView.providerHeader);
            const sections = yield Promise.all(headers.map((header) => __awaiter(this, void 0, void 0, function* () { return header.findElement(ScmView.locators.ScmView.providerRelative); })));
            return Promise.all(sections.map((section) => __awaiter(this, void 0, void 0, function* () { return new ScmProvider(section, this); })));
        });
    }
    /**
     * Initialize repository in the current folder if no SCM provider is found
     * @returns true if the action was completed succesfully, false if a provider already exists
     */
    initializeRepository() {
        return __awaiter(this, void 0, void 0, function* () {
            const buttons = yield this.findElements(ScmView.locators.ScmView.initButton);
            if (buttons.length > 0) {
                yield buttons[0].click();
                return true;
            }
            return false;
        });
    }
}
exports.ScmView = ScmView;
/**
 * Page object representing a repository in the source control view
 * Maps roughly to a view section of the source control view
 */
class ScmProvider extends AbstractElement_1.AbstractElement {
    constructor(element, view) {
        super(element, view);
    }
    /**
     * Get title of the scm provider
     */
    getTitle() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.findElement(ScmProvider.locators.ScmView.providerTitle).getAttribute('innerHTML');
        });
    }
    /**
     * Get type of the scm provider (e.g. Git)
     */
    getType() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.findElement(ScmProvider.locators.ScmView.providerType).getAttribute('innerHTML');
        });
    }
    /**
     * Find an action button for the SCM provider by title and click it. (e.g 'Commit')
     * @param title Title of the action button to click
     * @returns true if the given action could be performed, false if the button doesn't exist
     */
    takeAction(title) {
        return __awaiter(this, void 0, void 0, function* () {
            const header = yield this.findElement(ScmProvider.locators.ScmView.providerHeader);
            let actions = [];
            if ((yield header.getAttribute('class')).indexOf('hidden') > -1) {
                const view = this.enclosingItem;
                actions = yield view.getTitlePart().getActions();
            }
            else {
                yield this.getDriver().actions().mouseMove(this).perform();
                actions = yield header.findElements(ScmProvider.locators.ScmView.action);
            }
            const names = yield Promise.all(actions.map((action) => __awaiter(this, void 0, void 0, function* () { return action.getAttribute('title'); })));
            const index = names.findIndex(item => item === title);
            if (index > -1) {
                yield actions[index].click();
                return true;
            }
            return false;
        });
    }
    /**
     * Open a context menu using the 'More Actions...' button
     * @returns Promise resolving to a ContextMenu object
     */
    openMoreActions() {
        return __awaiter(this, void 0, void 0, function* () {
            const header = yield this.findElement(ScmProvider.locators.ScmView.providerHeader);
            if ((yield header.getAttribute('class')).indexOf('hidden') > -1) {
                return new MoreAction(this.enclosingItem).openContextMenu();
            }
            else {
                yield this.getDriver().actions().mouseMove(this).perform();
                return new MoreAction(this).openContextMenu();
            }
        });
    }
    /**
     * Fill in the message field and send ctrl/cmd + enter to commit the changes
     * @param message the commit message to use
     * @returns promise resolving once the keypresses are sent
     */
    commitChanges(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const input = yield this.findElement(ScmProvider.locators.ScmView.inputField);
            yield input.clear();
            yield input.sendKeys(message);
            yield input.sendKeys(selenium_webdriver_1.Key.chord(ScmProvider.ctlKey, selenium_webdriver_1.Key.ENTER));
        });
    }
    /**
     * Get page objects for all tree items representing individual changes
     * @param staged when true, finds staged changes; otherwise finds unstaged changes
     * @returns promise resolving to ScmChange object array
     */
    getChanges(staged = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const changes = yield this.getChangeCount(staged);
            const label = staged ? 'STAGED CHANGES' : 'CHANGES';
            let elements = [];
            if (changes > 0) {
                let i = -1;
                elements = yield this.findElements(ScmProvider.locators.ScmView.changeItem);
                for (const [index, item] of elements.entries()) {
                    const name = yield item.findElement(ScmProvider.locators.ScmView.changeName);
                    if ((yield name.getText()) === label) {
                        i = index + 1;
                        break;
                    }
                }
                if (i < 0) {
                    return [];
                }
                elements = elements.slice(i, i + changes);
            }
            return Promise.all(elements.map((element) => __awaiter(this, void 0, void 0, function* () { return new ScmChange(element, this).wait(); })));
        });
    }
    /**
     * Get the number of changes for a given section
     * @param staged when true, counts the staged changes, unstaged otherwise
     * @returns promise resolving to number of changes in the given subsection
     */
    getChangeCount(staged = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const locator = staged ? ScmProvider.locators.ScmView.stagedChanges : ScmProvider.locators.ScmView.changes;
            const rows = yield this.findElements(locator);
            if (rows.length < 1) {
                return 0;
            }
            const count = yield rows[0].findElement(ScmChange.locators.ScmView.changeCount);
            return +(yield count.getText());
        });
    }
}
exports.ScmProvider = ScmProvider;
/**
 * Page object representing a SCM change tree item
 */
class ScmChange extends ElementWithContextMenu_1.ElementWithContexMenu {
    constructor(row, provider) {
        super(row, provider);
    }
    /**
     * Get label as a string
     */
    getLabel() {
        return __awaiter(this, void 0, void 0, function* () {
            const label = yield this.findElement(ScmChange.locators.ScmView.changeLabel);
            return label.getText();
        });
    }
    /**
     * Get description as a string
     */
    getDescription() {
        return __awaiter(this, void 0, void 0, function* () {
            const desc = yield this.findElements(ScmChange.locators.ScmView.changeDesc);
            if (desc.length < 1) {
                return '';
            }
            return desc[0].getText();
        });
    }
    /**
     * Get the status string (e.g. 'Modified')
     */
    getStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.findElement(ScmChange.locators.ScmView.resource);
            const status = yield res.getAttribute('data-tooltip');
            if (status && status.length > 0) {
                return status;
            }
            return 'folder';
        });
    }
    /**
     * Find if the item is expanded
     * @returns promise resolving to true if change is expanded, to false otherwise
     */
    isExpanded() {
        return __awaiter(this, void 0, void 0, function* () {
            const twisties = yield this.findElements(ScmChange.locators.ScmView.expand);
            if (twisties.length < 1) {
                return true;
            }
            return (yield twisties[0].getAttribute('class')).indexOf('collapsed') < 0;
        });
    }
    /**
     * Expand or collapse a change item if possible, only works for folders in hierarchical view mode
     * @param expand true to expand the item, false to collapse
     * @returns promise resolving to true if the item changed state, to false otherwise
     */
    toggleExpand(expand) {
        return __awaiter(this, void 0, void 0, function* () {
            if ((yield this.isExpanded()) !== expand) {
                yield this.click();
                return true;
            }
            return false;
        });
    }
    /**
     * Find and click an action button available to a given change tree item
     * @param title title of the action button (e.g 'Stage Changes')
     * @returns promise resolving to true if the action was performed successfully,
     * false if the given button does not exist
     */
    takeAction(title) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getDriver().actions().mouseMove(this).perform();
            const actions = yield this.findElements(ScmChange.locators.ScmView.action);
            const names = yield Promise.all(actions.map((action) => __awaiter(this, void 0, void 0, function* () { return action.getAttribute('title'); })));
            const index = names.findIndex(item => item === title);
            if (index > -1) {
                yield actions[index].click();
                return true;
            }
            return false;
        });
    }
}
exports.ScmChange = ScmChange;
class MoreAction extends ElementWithContextMenu_1.ElementWithContexMenu {
    constructor(scm) {
        super(MoreAction.locators.ScmView.more, scm);
    }
    openContextMenu() {
        const _super = Object.create(null, {
            openContextMenu: { get: () => super.openContextMenu }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield this.click();
            const shadowRootHost = yield this.enclosingItem.findElements(selenium_webdriver_1.By.className('shadow-root-host'));
            yield this.getDriver().actions().sendKeys(selenium_webdriver_1.Key.ESCAPE).perform();
            if (shadowRootHost.length > 0) {
                if ((yield this.getAttribute('aria-expanded')) !== 'true') {
                    yield this.click();
                }
                const shadowRoot = yield this.getDriver().executeScript('return arguments[0].shadowRoot', shadowRootHost[0]);
                return new __1.ContextMenu(shadowRoot).wait();
            }
            return _super.openContextMenu.call(this);
        });
    }
}
exports.MoreAction = MoreAction;
//# sourceMappingURL=ScmView.js.map