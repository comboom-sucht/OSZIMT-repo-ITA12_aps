"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ViewPanelAction = exports.ViewSection = void 0;
const selenium_webdriver_1 = require("selenium-webdriver");
const __1 = require("../..");
const AbstractElement_1 = require("../AbstractElement");
/**
 * Page object representing a collapsible content section of the side bar view
 */
class ViewSection extends AbstractElement_1.AbstractElement {
    constructor(panel, content) {
        super(panel, content);
    }
    /**
     * Get the title of the section as string
     * @returns Promise resolving to section title
     */
    getTitle() {
        return __awaiter(this, void 0, void 0, function* () {
            const title = yield this.findElement(ViewSection.locators.ViewSection.title);
            return yield title.getAttribute(ViewSection.locators.ViewSection.titleText);
        });
    }
    /**
     * Expand the section if collapsed
     * @returns Promise resolving when the section is expanded
     */
    expand() {
        return __awaiter(this, void 0, void 0, function* () {
            if (yield this.isHeaderHidden()) {
                return;
            }
            if (!(yield this.isExpanded())) {
                const panel = yield this.findElement(ViewSection.locators.ViewSection.header);
                yield panel.click();
                yield this.getDriver().wait(__1.waitForAttributeValue(panel, ViewSection.locators.ViewSection.headerExpanded, 'true'), 1000);
            }
        });
    }
    /**
     * Collapse the section if expanded
     * @returns Promise resolving when the section is collapsed
     */
    collapse() {
        return __awaiter(this, void 0, void 0, function* () {
            if (yield this.isHeaderHidden()) {
                return;
            }
            if (yield this.isExpanded()) {
                const panel = yield this.findElement(ViewSection.locators.ViewSection.header);
                yield panel.click();
                yield this.getDriver().wait(__1.waitForAttributeValue(panel, ViewSection.locators.ViewSection.headerExpanded, 'false'), 1000);
            }
        });
    }
    /**
     * Finds whether the section is expanded
     * @returns Promise resolving to true/false
     */
    isExpanded() {
        return __awaiter(this, void 0, void 0, function* () {
            const header = yield this.findElement(ViewSection.locators.ViewSection.header);
            const expanded = yield header.getAttribute(ViewSection.locators.ViewSection.headerExpanded);
            return expanded === 'true';
        });
    }
    /**
     * Finds [Welcome Content](https://code.visualstudio.com/api/extension-guides/tree-view#welcome-content)
     * present in this ViewSection and returns it. If none is found, then `undefined` is returned
     *
     */
    findWelcomeContent() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield this.findElement(ViewSection.locators.ViewSection.welcomeContent);
                return new __1.WelcomeContentSection(res, this);
            }
            catch (_err) {
                return undefined;
            }
        });
    }
    /**
     * Retrieve the action buttons on the section's header
     * @returns Promise resolving to array of ViewPanelAction objects
     */
    getActions() {
        return __awaiter(this, void 0, void 0, function* () {
            const actions = [];
            if (!(yield this.isHeaderHidden())) {
                const header = yield this.findElement(ViewSection.locators.ViewSection.header);
                const act = yield header.findElement(ViewSection.locators.ViewSection.actions);
                const elements = yield act.findElements(ViewSection.locators.ViewSection.button);
                for (const element of elements) {
                    actions.push(yield new ViewPanelAction(yield element.getAttribute(ViewSection.locators.ViewSection.buttonLabel), this).wait());
                }
            }
            return actions;
        });
    }
    /**
     * Retrieve an action button on the sections's header by its label
     * @param label label/title of the button
     * @returns ViewPanelAction object
     */
    getAction(label) {
        return new ViewPanelAction(label, this);
    }
    isHeaderHidden() {
        return __awaiter(this, void 0, void 0, function* () {
            const header = yield this.findElement(ViewSection.locators.ViewSection.header);
            return (yield header.getAttribute('class')).indexOf('hidden') > -1;
        });
    }
}
exports.ViewSection = ViewSection;
/**
 * Action button on the header of a view section
 */
class ViewPanelAction extends AbstractElement_1.AbstractElement {
    constructor(label, viewPart) {
        super(ViewPanelAction.locators.ViewSection.actionConstructor(label), viewPart);
        this.label = label;
    }
    /**
     * Get label of the action button
     */
    getLabel() {
        return this.label;
    }
    wait(timeout = 1000) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getDriver().wait(selenium_webdriver_1.until.elementIsEnabled(this), timeout);
            return this;
        });
    }
}
exports.ViewPanelAction = ViewPanelAction;
//# sourceMappingURL=ViewSection.js.map