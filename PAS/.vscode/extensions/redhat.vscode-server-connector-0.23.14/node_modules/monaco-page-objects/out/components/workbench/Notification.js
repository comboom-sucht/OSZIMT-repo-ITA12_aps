"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CenterNotification = exports.StandaloneNotification = exports.Notification = exports.NotificationType = void 0;
const ElementWithContextMenu_1 = require("../ElementWithContextMenu");
const AbstractElement_1 = require("../AbstractElement");
const selenium_webdriver_1 = require("selenium-webdriver");
/**
 * Available types of notifications
 */
var NotificationType;
(function (NotificationType) {
    NotificationType["Info"] = "info";
    NotificationType["Warning"] = "warning";
    NotificationType["Error"] = "error";
    NotificationType["Any"] = "any";
})(NotificationType = exports.NotificationType || (exports.NotificationType = {}));
/**
 * Abstract element representing a notification
 */
class Notification extends ElementWithContextMenu_1.ElementWithContexMenu {
    /**
     * Get the message of the notification
     * @returns Promise resolving to notification message
     */
    getMessage() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.findElement(Notification.locators.Notification.message).getText();
        });
    }
    /**
     * Get the type of the notification
     * @returns Promise resolving to NotificationType
     */
    getType() {
        return __awaiter(this, void 0, void 0, function* () {
            const iconType = yield this.findElement(Notification.locators.Notification.icon).getAttribute('class');
            if (iconType.indexOf('icon-info') > -1) {
                return NotificationType.Info;
            }
            else if (iconType.indexOf('icon-warning') > -1) {
                return NotificationType.Warning;
            }
            else {
                return NotificationType.Error;
            }
        });
    }
    /**
     * Get the source of the notification as text
     * @returns Promise resolving to notification source
     */
    getSource() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.findElement(Notification.locators.Notification.source).getAttribute('title');
        });
    }
    /**
     * Find whether the notification has an active progress bar
     * @returns Promise resolving to true/false
     */
    hasProgress() {
        return __awaiter(this, void 0, void 0, function* () {
            const klass = yield this.findElement(Notification.locators.Notification.progress).getAttribute('class');
            return klass.indexOf('done') < 0;
        });
    }
    /**
     * Dismiss the notification
     * @returns Promise resolving when notification is dismissed
     */
    dismiss() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getDriver().actions().mouseMove(this).perform();
            const btn = yield this.findElement(Notification.locators.Notification.dismiss);
            yield this.getDriver().wait(selenium_webdriver_1.until.elementIsVisible(btn), 2000);
            yield btn.click();
        });
    }
    /**
     * Get the action buttons of the notification as an array
     * of NotificationButton objects
     * @returns Promise resolving to array of NotificationButton objects
     */
    getActions() {
        return __awaiter(this, void 0, void 0, function* () {
            const buttons = [];
            const elements = yield this.findElement(Notification.locators.Notification.actions)
                .findElements(Notification.locators.Notification.action);
            for (const button of elements) {
                buttons.push(yield new NotificationButton(yield button.getAttribute(Notification.locators.Notification.actionLabel), this).wait());
            }
            return buttons;
        });
    }
    /**
     * Click on an action button with the given title
     * @param title title of the action/button
     * @returns Promise resolving when the select button is pressed
     */
    takeAction(title) {
        return __awaiter(this, void 0, void 0, function* () {
            yield new NotificationButton(title, this).click();
        });
    }
}
exports.Notification = Notification;
/**
 * Notification displayed on its own in the notifications-toasts container
 */
class StandaloneNotification extends Notification {
    constructor(notification) {
        super(notification, StandaloneNotification.locators.Notification.standaloneContainer);
    }
}
exports.StandaloneNotification = StandaloneNotification;
/**
 * Notification displayed within the notifications center
 */
class CenterNotification extends Notification {
    constructor(notification) {
        super(notification, CenterNotification.locators.NotificationsCenter.constructor);
    }
}
exports.CenterNotification = CenterNotification;
/**
 * Notification button
 */
class NotificationButton extends AbstractElement_1.AbstractElement {
    constructor(title, notification) {
        super(NotificationButton.locators.Notification.buttonConstructor(title), notification);
        this.title = title;
    }
    getTitle() {
        return this.title;
    }
}
//# sourceMappingURL=Notification.js.map