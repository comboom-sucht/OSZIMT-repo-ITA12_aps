"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LinkSetting = exports.CheckboxSetting = exports.TextSetting = exports.ComboSetting = exports.Setting = exports.SettingsEditor = void 0;
const Editor_1 = require("./Editor");
const selenium_webdriver_1 = require("selenium-webdriver");
const AbstractElement_1 = require("../AbstractElement");
const __1 = require("../..");
/**
 * Page object representing the internal VSCode settings editor
 */
class SettingsEditor extends Editor_1.Editor {
    constructor(view = new __1.EditorView()) {
        super(view);
    }
    /**
     * Search for a setting with a particular title and category.
     * Returns an appropriate Setting object if the label is found,
     * undefined otherwise.
     *
     * If your setting has nested categories (i.e `example.general.test`),
     * pass in each category as a separate string.
     *
     * @param title title of the setting
     * @param categories category of the setting
     * @returns Promise resolving to a Setting object if found, undefined otherwise
     */
    findSetting(title, ...categories) {
        return __awaiter(this, void 0, void 0, function* () {
            const category = categories.join(' â€º ');
            const searchBox = yield this.findElement(SettingsEditor.locators.Editor.inputArea);
            yield searchBox.sendKeys(selenium_webdriver_1.Key.chord(SettingsEditor.ctlKey, 'a'));
            yield searchBox.sendKeys(`${category}: ${title}`);
            const count = yield this.findElement(SettingsEditor.locators.SettingsEditor.itemCount);
            let textCount = yield count.getText();
            yield this.getDriver().wait(() => __awaiter(this, void 0, void 0, function* () {
                yield new Promise(res => setTimeout(res, 1500));
                const text = yield count.getText();
                if (text !== textCount) {
                    textCount = text;
                    return false;
                }
                return true;
            }));
            let setting;
            const items = yield this.findElements(SettingsEditor.locators.SettingsEditor.itemRow);
            for (const item of items) {
                try {
                    return (yield this.createSetting(item, title, category)).wait();
                }
                catch (err) {
                }
            }
            return setting;
        });
    }
    /**
     * Switch between settings perspectives
     * Works only if your vscode instance has both user and workspace settings available
     *
     * @param perspective User or Workspace
     * @returns Promise that resolves when the appropriate button is clicked
     */
    switchToPerspective(perspective) {
        return __awaiter(this, void 0, void 0, function* () {
            const actions = yield this.findElement(SettingsEditor.locators.SettingsEditor.header)
                .findElement(SettingsEditor.locators.SettingsEditor.tabs)
                .findElement(SettingsEditor.locators.SettingsEditor.actions);
            yield actions.findElement(SettingsEditor.locators.SettingsEditor.action(perspective)).click();
        });
    }
    /**
     * Context menu is disabled in this editor, throw an error
     */
    openContextMenu() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Operation not supported');
        });
    }
    createSetting(element, title, category) {
        return __awaiter(this, void 0, void 0, function* () {
            yield element.findElement(SettingsEditor.locators.SettingsEditor.settingConstructor(title, category));
            try {
                // try a combo setting
                yield element.findElement(SettingsEditor.locators.SettingsEditor.comboSetting);
                return new ComboSetting(title, category, this);
            }
            catch (err) {
                try {
                    // try text setting
                    yield element.findElement(SettingsEditor.locators.SettingsEditor.textSetting);
                    return new TextSetting(title, category, this);
                }
                catch (err) {
                    try {
                        // try checkbox setting
                        yield element.findElement(SettingsEditor.locators.SettingsEditor.checkboxSetting);
                        return new CheckboxSetting(title, category, this);
                    }
                    catch (err) {
                        // try link setting
                        try {
                            yield element.findElement(SettingsEditor.locators.SettingsEditor.linkButton);
                            return new LinkSetting(title, category, this);
                        }
                        catch (err) {
                            throw new Error('Setting type not supported');
                        }
                    }
                }
            }
        });
    }
}
exports.SettingsEditor = SettingsEditor;
/**
 * Abstract item representing a Setting with title, description and
 * an input element (combo/textbox/checkbox/link)
 */
class Setting extends AbstractElement_1.AbstractElement {
    constructor(title, category, settings) {
        super(SettingsEditor.locators.SettingsEditor.settingConstructor(title, category), settings);
        this.title = title;
        this.category = category;
    }
    /**
     * Get the category of the setting
     * All settings are labeled as Category: Title
     */
    getCategory() {
        return this.category;
    }
    /**
     * Get description of the setting
     * @returns Promise resolving to setting description
     */
    getDescription() {
        return __awaiter(this, void 0, void 0, function* () {
            const desc = yield this.findElement(SettingsEditor.locators.SettingsEditor.settingDesctiption);
            return yield desc.getText();
        });
    }
    /**
     * Get title of the setting
     */
    getTitle() {
        return this.title;
    }
}
exports.Setting = Setting;
/**
 * Setting with a combo box
 */
class ComboSetting extends Setting {
    getValue() {
        return __awaiter(this, void 0, void 0, function* () {
            const combo = yield this.findElement(SettingsEditor.locators.SettingsEditor.comboSetting);
            return yield combo.getAttribute('title');
        });
    }
    setValue(value) {
        return __awaiter(this, void 0, void 0, function* () {
            const rows = yield this.getOptions();
            for (let i = 0; i < rows.length; i++) {
                if ((yield rows[i].getAttribute('class')).indexOf('disabled') < 0) {
                    const text = yield rows[i].findElement(SettingsEditor.locators.SettingsEditor.comboOption).getText();
                    if (value === text) {
                        return yield rows[i].click();
                    }
                }
            }
        });
    }
    /**
     * Get the labels of all options from the combo
     * @returns Promise resolving to array of string values
     */
    getValues() {
        return __awaiter(this, void 0, void 0, function* () {
            const values = [];
            const rows = yield this.getOptions();
            for (const row of rows) {
                values.push(yield row.findElement(SettingsEditor.locators.SettingsEditor.comboOption).getText());
            }
            return values;
        });
    }
    getOptions() {
        return __awaiter(this, void 0, void 0, function* () {
            const menu = yield this.openCombo();
            return yield menu.findElements(SettingsEditor.locators.SettingsEditor.itemRow);
        });
    }
    openCombo() {
        return __awaiter(this, void 0, void 0, function* () {
            const combo = yield this.findElement(SettingsEditor.locators.SettingsEditor.comboSetting);
            const workbench = yield this.getDriver().findElement(SettingsEditor.locators.Workbench.constructor);
            const menus = yield workbench.findElements(SettingsEditor.locators.ContextMenu.contextView);
            let menu;
            if (menus.length < 1) {
                yield combo.click();
                menu = yield workbench.findElement(SettingsEditor.locators.ContextMenu.contextView);
                return menu;
            }
            else if (yield menus[0].isDisplayed()) {
                yield combo.click();
                yield this.getDriver().sleep(200);
            }
            yield combo.click();
            menu = yield workbench.findElement(SettingsEditor.locators.ContextMenu.contextView);
            return menu;
        });
    }
}
exports.ComboSetting = ComboSetting;
/**
 * Setting with a text box input
 */
class TextSetting extends Setting {
    getValue() {
        return __awaiter(this, void 0, void 0, function* () {
            const input = yield this.findElement(SettingsEditor.locators.SettingsEditor.textSetting);
            return yield input.getAttribute('value');
        });
    }
    setValue(value) {
        return __awaiter(this, void 0, void 0, function* () {
            const input = yield this.findElement(SettingsEditor.locators.SettingsEditor.textSetting);
            yield input.clear();
            yield input.sendKeys(value);
        });
    }
}
exports.TextSetting = TextSetting;
/**
 * Setting with a checkbox
 */
class CheckboxSetting extends Setting {
    getValue() {
        return __awaiter(this, void 0, void 0, function* () {
            const checkbox = yield this.findElement(SettingsEditor.locators.SettingsEditor.checkboxSetting);
            const checked = yield checkbox.getAttribute(SettingsEditor.locators.SettingsEditor.checkboxChecked);
            if (checked === 'true') {
                return true;
            }
            return false;
        });
    }
    setValue(value) {
        return __awaiter(this, void 0, void 0, function* () {
            const checkbox = yield this.findElement(SettingsEditor.locators.SettingsEditor.checkboxSetting);
            if ((yield this.getValue()) !== value) {
                yield checkbox.click();
            }
        });
    }
}
exports.CheckboxSetting = CheckboxSetting;
/**
 * Setting with no value, with a link to settings.json instead
 */
class LinkSetting extends Setting {
    getValue() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Value not available in settings editor.');
        });
    }
    setValue(value) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Value not available in settings editor.');
        });
    }
    /**
     * Open the link that leads to the value in settings.json
     * @returns Promise resolving when the link has been clicked
     */
    openLink() {
        return __awaiter(this, void 0, void 0, function* () {
            const link = yield this.findElement(SettingsEditor.locators.SettingsEditor.linkButton);
            yield link.click();
        });
    }
}
exports.LinkSetting = LinkSetting;
//# sourceMappingURL=SettingsEditor.js.map