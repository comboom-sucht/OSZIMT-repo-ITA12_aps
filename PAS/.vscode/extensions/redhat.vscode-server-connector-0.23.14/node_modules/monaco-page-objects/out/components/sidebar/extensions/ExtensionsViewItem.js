"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExtensionsViewItem = void 0;
const ViewItem_1 = require("../ViewItem");
const selenium_webdriver_1 = require("selenium-webdriver");
/**
 * Page object representing an extension in the extensions view
 */
class ExtensionsViewItem extends ViewItem_1.ViewItem {
    constructor(extensionElement, section) {
        super(extensionElement, section);
    }
    /**
     * Get title of the extension
     */
    getTitle() {
        return __awaiter(this, void 0, void 0, function* () {
            const title = yield this.findElement(ExtensionsViewItem.locators.ExtensionsViewSection.itemTitle);
            return title.getText();
        });
    }
    /**
     * Get version of the extension
     * @returns Promise resolving to version string
     */
    getVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            const version = yield this.findElement(ExtensionsViewItem.locators.ExtensionsViewItem.version);
            return version.getText();
        });
    }
    /**
     * Get the author of the extension
     * @returns Promise resolving to displayed author
     */
    getAuthor() {
        return __awaiter(this, void 0, void 0, function* () {
            const author = yield this.findElement(ExtensionsViewItem.locators.ExtensionsViewItem.author);
            return author.getText();
        });
    }
    /**
     * Get the description of the extension
     * @returns Promise resolving to description
     */
    getDescription() {
        return __awaiter(this, void 0, void 0, function* () {
            const description = yield this.findElement(ExtensionsViewItem.locators.ExtensionsViewItem.description);
            return description.getText();
        });
    }
    /**
     * Find if the extension is installed
     * @returns Promise resolving to true/false
     */
    isInstalled() {
        return __awaiter(this, void 0, void 0, function* () {
            const button = yield this.findElement(ExtensionsViewItem.locators.ExtensionsViewItem.install);
            if ((yield button.getAttribute('class')).indexOf('disabled') > -1) {
                return true;
            }
            return false;
        });
    }
    /**
     * Open the management context menu if the extension is installed
     * @returns Promise resolving to ContextMenu object
     */
    manage() {
        return __awaiter(this, void 0, void 0, function* () {
            const button = yield this.findElement(ExtensionsViewItem.locators.ExtensionsViewItem.manage);
            if ((yield button.getAttribute('class')).indexOf('disabled') > -1) {
                throw new Error(`Extension '${yield this.getTitle()}' is not installed`);
            }
            return this.openContextMenu();
        });
    }
    /**
     * Install the extension if not installed already.
     *
     * Will wait for the extension to finish installing. To skip the wait, set timeout to 0.
     *
     * @param timeout timeout to wait for the installation in milliseconds, default unlimited, set to 0 to skip waiting
     * @returns Promise resolving when the installation finishes or is skipped
     */
    install(timeout = 300000) {
        return __awaiter(this, void 0, void 0, function* () {
            if (yield this.isInstalled()) {
                return;
            }
            const button = yield this.findElement(ExtensionsViewItem.locators.ExtensionsViewItem.install);
            const manage = yield this.findElement(ExtensionsViewItem.locators.ExtensionsViewItem.manage);
            yield button.click();
            if (timeout > 0) {
                yield this.getDriver().wait(selenium_webdriver_1.until.elementIsVisible(manage), timeout);
            }
        });
    }
}
exports.ExtensionsViewItem = ExtensionsViewItem;
//# sourceMappingURL=ExtensionsViewItem.js.map