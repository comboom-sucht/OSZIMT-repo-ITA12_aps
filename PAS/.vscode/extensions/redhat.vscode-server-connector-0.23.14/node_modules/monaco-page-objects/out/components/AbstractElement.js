"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractElement = void 0;
const selenium_webdriver_1 = require("selenium-webdriver");
/**
 * Default wrapper for webelement
 */
class AbstractElement extends selenium_webdriver_1.WebElement {
    /**
     * Constructs a new element from a Locator or an existing WebElement
     * @param base WebDriver compatible Locator for the given element or a reference to an existing WeBelement
     * @param enclosingItem Locator or a WebElement reference to an element containing the element being constructed
     * this will be used to narrow down the search for the underlying DOM element
     */
    constructor(base, enclosingItem) {
        let item = AbstractElement.driver.findElement(selenium_webdriver_1.By.css('html'));
        if (!enclosingItem) {
            enclosingItem = item;
        }
        if (enclosingItem instanceof selenium_webdriver_1.WebElement) {
            item = enclosingItem;
        }
        else {
            item = AbstractElement.driver.findElement(enclosingItem);
        }
        if (base instanceof selenium_webdriver_1.WebElement) {
            super(AbstractElement.driver, base.getId());
        }
        else {
            super(AbstractElement.driver, item.findElement(base).getId());
        }
        this.enclosingItem = item;
    }
    /**
     * Wait for the element to become visible
     * @param timeout custom timeout for the wait
     * @returns thenable self reference
     */
    wait(timeout = 5000) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getDriver().wait(selenium_webdriver_1.until.elementIsVisible(this), timeout);
            return this;
        });
    }
    /**
     * Return a reference to the WebElement containing this element
     */
    getEnclosingElement() {
        return this.enclosingItem;
    }
    static init(locators, driver, browser, version) {
        AbstractElement.locators = locators;
        AbstractElement.driver = driver;
        AbstractElement.versionInfo = { version: version, browser: browser };
    }
}
exports.AbstractElement = AbstractElement;
AbstractElement.ctlKey = process.platform === 'darwin' ? selenium_webdriver_1.Key.COMMAND : selenium_webdriver_1.Key.CONTROL;
//# sourceMappingURL=AbstractElement.js.map