"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EditorTab = exports.EditorGroup = exports.EditorView = void 0;
const AbstractElement_1 = require("../AbstractElement");
const __1 = require("../..");
const path = require("path");
const SettingsEditor_1 = require("./SettingsEditor");
const WebView_1 = require("./WebView");
const DiffEditor_1 = require("./DiffEditor");
const ElementWithContextMenu_1 = require("../ElementWithContextMenu");
/**
 * View handling the open editors
 */
class EditorView extends AbstractElement_1.AbstractElement {
    constructor() {
        super(EditorView.locators.EditorView.constructor, EditorView.locators.Workbench.constructor);
    }
    /**
     * Switch to an editor tab with the given title
     * @param title title of the tab
     * @param groupIndex zero based index for the editor group (0 for the left most group)
     * @returns Promise resolving to Editor object
     */
    openEditor(title, groupIndex = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            const group = yield this.getEditorGroup(groupIndex);
            return group.openEditor(title);
        });
    }
    /**
     * Close an editor tab with the given title
     * @param title title of the tab
     * @param groupIndex zero based index for the editor group (0 for the left most group)
     * @returns Promise resolving when the tab's close button is pressed
     */
    closeEditor(title, groupIndex = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            const group = yield this.getEditorGroup(groupIndex);
            return group.closeEditor(title);
        });
    }
    /**
     * Close all open editor tabs
     * @param groupIndex optional index to specify an editor group
     * @returns Promise resolving once all tabs have had their close button pressed
     */
    closeAllEditors(groupIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            let groups = yield this.getEditorGroups();
            if (groupIndex !== undefined) {
                return groups[0].closeAllEditors();
            }
            while (groups.length > 0 && (yield groups[0].getOpenEditorTitles()).length > 0) {
                yield groups[0].closeAllEditors();
                groups = yield this.getEditorGroups();
            }
        });
    }
    /**
     * Retrieve all open editor tab titles in an array
     * @param groupIndex optional index to specify an editor group, if left empty will search all groups
     * @returns Promise resolving to array of editor titles
     */
    getOpenEditorTitles(groupIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            const groups = yield this.getEditorGroups();
            if (groupIndex !== undefined) {
                return groups[groupIndex].getOpenEditorTitles();
            }
            const titles = [];
            for (const group of groups) {
                titles.push(...(yield group.getOpenEditorTitles()));
            }
            return titles;
        });
    }
    /**
     * Retrieve an editor tab from a given group by title
     * @param title title of the tab
     * @param groupIndex zero based index of the editor group, default 0 (leftmost one)
     * @returns promise resolving to EditorTab object
     */
    getTabByTitle(title, groupIndex = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            const group = yield this.getEditorGroup(groupIndex);
            return group.getTabByTitle(title);
        });
    }
    /**
     * Retrieve all open editor tabs
     * @param groupIndex index of group to search for tabs, if left undefined, all groups are searched
     * @returns promise resolving to EditorTab list
     */
    getOpenTabs(groupIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            const groups = yield this.getEditorGroups();
            if (groupIndex !== undefined) {
                return groups[groupIndex].getOpenTabs();
            }
            const tabs = [];
            for (const group of groups) {
                tabs.push(...(yield group.getOpenTabs()));
            }
            return tabs;
        });
    }
    /**
     * Retrieve the active editor tab
     * @returns promise resolving to EditorTab object, undefined if no tab is active
     */
    getActiveTab() {
        return __awaiter(this, void 0, void 0, function* () {
            const tabs = yield this.getOpenTabs();
            const klasses = yield Promise.all(tabs.map((tab) => __awaiter(this, void 0, void 0, function* () { return tab.getAttribute('class'); })));
            const index = klasses.findIndex(klass => klass.indexOf('active') > -1);
            if (index > -1) {
                return tabs[index];
            }
            return undefined;
        });
    }
    /**
     * Retrieve all editor groups in a list, sorted left to right
     * @returns promise resolving to an array of EditorGroup objects
     */
    getEditorGroups() {
        return __awaiter(this, void 0, void 0, function* () {
            const elements = yield this.findElements(EditorGroup.locators.EditorView.editorGroup);
            const groups = yield Promise.all(elements.map((element) => __awaiter(this, void 0, void 0, function* () { return new EditorGroup(element, this).wait(); })));
            // sort the groups by x coordinates, so the leftmost is always at index 0
            for (let i = 0; i < groups.length - 1; i++) {
                for (let j = 0; j < groups.length - i - 1; j++) {
                    if ((yield groups[j].getLocation()).x > (yield groups[j + 1].getLocation()).x) {
                        let temp = groups[j];
                        groups[j] = groups[j + 1];
                        groups[j + 1] = temp;
                    }
                }
            }
            return groups;
        });
    }
    /**
     * Retrieve an editor group with a given index (counting from left to right)
     * @param index zero based index of the editor group (leftmost group has index 0)
     * @returns promise resolving to an EditorGroup object
     */
    getEditorGroup(index) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.getEditorGroups())[index];
        });
    }
    /**
     * Get editor actions of a select editor group
     * @param groupIndex zero based index of the editor group (leftmost group has index 0), default 0
     * @returns promise resolving to list of WebElement objects
     */
    getActions(groupIndex = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            const group = yield this.getEditorGroup(groupIndex);
            return group.getActions();
        });
    }
    /**
     * Get editor action of a select editor group, search by title
     * @param groupIndex zero based index of the editor group (leftmost group has index 0), default 0
     * @returns promise resolving to WebElement object if found, undefined otherwise
     */
    getAction(title, groupIndex = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            const group = yield this.getEditorGroup(groupIndex);
            return group.getAction(title);
        });
    }
}
exports.EditorView = EditorView;
/**
 * Page object representing an editor group
 */
class EditorGroup extends AbstractElement_1.AbstractElement {
    constructor(element, view = new EditorView()) {
        super(element, view);
    }
    /**
     * Switch to an editor tab with the given title
     * @param title title of the tab
     * @returns Promise resolving to Editor object
     */
    openEditor(title) {
        return __awaiter(this, void 0, void 0, function* () {
            const tab = yield this.getTabByTitle(title);
            yield tab.select();
            try {
                yield this.findElement(EditorView.locators.EditorView.settingsEditor);
                return new SettingsEditor_1.SettingsEditor(this).wait();
            }
            catch (err) {
                try {
                    yield this.findElement(EditorView.locators.EditorView.webView);
                    return new WebView_1.WebView(this).wait();
                }
                catch (err) {
                    try {
                        yield this.findElement(EditorView.locators.EditorView.diffEditor);
                        return new DiffEditor_1.DiffEditor(this).wait();
                    }
                    catch (err) {
                        return new __1.TextEditor(this).wait();
                    }
                }
            }
        });
    }
    /**
     * Close an editor tab with the given title
     * @param title title of the tab
     * @returns Promise resolving when the tab's close button is pressed
     */
    closeEditor(title) {
        return __awaiter(this, void 0, void 0, function* () {
            const tab = yield this.getTabByTitle(title);
            yield EditorView.driver.actions().mouseMove(tab).perform();
            const closeButton = yield tab.findElement(EditorView.locators.EditorView.closeTab);
            yield closeButton.click();
        });
    }
    /**
     * Close all open editor tabs
     * @returns Promise resolving once all tabs have had their close button pressed
     */
    closeAllEditors() {
        return __awaiter(this, void 0, void 0, function* () {
            let titles = yield this.getOpenEditorTitles();
            while (titles.length > 0) {
                yield this.closeEditor(titles[0]);
                try {
                    // check if the group still exists
                    yield this.getTagName();
                }
                catch (err) {
                    break;
                }
                titles = yield this.getOpenEditorTitles();
            }
        });
    }
    /**
     * Retrieve all open editor tab titles in an array
     * @returns Promise resolving to array of editor titles
     */
    getOpenEditorTitles() {
        return __awaiter(this, void 0, void 0, function* () {
            const tabs = yield this.findElements(EditorView.locators.EditorView.tab);
            const titles = [];
            for (const tab of tabs) {
                const title = path.basename(yield tab.getAttribute(EditorView.locators.EditorView.tabTitle));
                titles.push(title);
            }
            return titles;
        });
    }
    /**
     * Retrieve an editor tab by title
     * @param title title of the tab
     * @returns promise resolving to EditorTab object
     */
    getTabByTitle(title) {
        return __awaiter(this, void 0, void 0, function* () {
            const tabs = yield this.findElements(EditorView.locators.EditorView.tab);
            let tab;
            for (const element of tabs) {
                const label = yield element.getAttribute(EditorView.locators.EditorView.tabLabel);
                if (label.startsWith(`${title}${EditorView.locators.EditorView.tabSeparator}`)) {
                    tab = element;
                    break;
                }
            }
            if (!tab) {
                throw new Error(`No editor with title '${title}' available`);
            }
            return new EditorTab(tab, this.enclosingItem);
        });
    }
    /**
     * Retrieve all open editor tabs
     * @returns promise resolving to EditorTab list
     */
    getOpenTabs() {
        return __awaiter(this, void 0, void 0, function* () {
            const tabs = yield this.findElements(EditorView.locators.EditorView.tab);
            return Promise.all(tabs.map((tab) => __awaiter(this, void 0, void 0, function* () { return new EditorTab(tab, this.enclosingItem).wait(); })));
        });
    }
    /**
     * Retrieve the active editor tab
     * @returns promise resolving to EditorTab object, undefined if no tab is active
     */
    getActiveTab() {
        return __awaiter(this, void 0, void 0, function* () {
            const tabs = yield this.getOpenTabs();
            const klasses = yield Promise.all(tabs.map((tab) => __awaiter(this, void 0, void 0, function* () { return tab.getAttribute('class'); })));
            const index = klasses.findIndex(klass => klass.indexOf('active') > -1);
            if (index > -1) {
                return tabs[index];
            }
            return undefined;
        });
    }
    /**
     * Retrieve the editor action buttons as WebElements
     * @returns promise resolving to list of WebElement objects
     */
    getActions() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.findElement(EditorGroup.locators.EditorView.actionContainer).findElements(EditorGroup.locators.EditorView.actionItem);
        });
    }
    /**
     * Find an editor action button by title
     * @param title title of the button
     * @returns promise resolving to WebElement representing the button if found, undefined otherwise
     */
    getAction(title) {
        return __awaiter(this, void 0, void 0, function* () {
            const actions = yield this.getActions();
            for (const item of actions) {
                if ((yield item.getAttribute('title')) === title) {
                    return item;
                }
            }
            return undefined;
        });
    }
}
exports.EditorGroup = EditorGroup;
/**
 * Page object for editor view tab
 */
class EditorTab extends ElementWithContextMenu_1.ElementWithContexMenu {
    constructor(element, view) {
        super(element, view);
    }
    /**
     * Get the tab title as string
     */
    getTitle() {
        return __awaiter(this, void 0, void 0, function* () {
            const title = path.basename(yield this.getAttribute(EditorView.locators.EditorView.tabTitle));
            return title;
        });
    }
    /**
     * Select (click) the tab
     */
    select() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.click();
        });
    }
}
exports.EditorTab = EditorTab;
//# sourceMappingURL=EditorView.js.map