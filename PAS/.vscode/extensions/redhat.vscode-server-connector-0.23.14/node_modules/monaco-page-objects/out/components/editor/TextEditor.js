"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FindWidget = exports.TextEditor = void 0;
const __1 = require("../..");
const selenium_webdriver_1 = require("selenium-webdriver");
const url_1 = require("url");
const clipboard = require("clipboardy");
const StatusBar_1 = require("../statusBar/StatusBar");
const Editor_1 = require("./Editor");
const ElementWithContextMenu_1 = require("../ElementWithContextMenu");
const AbstractElement_1 = require("../AbstractElement");
/**
 * Page object representing the active text editor
 */
class TextEditor extends Editor_1.Editor {
    /**
     * Find whether the active editor has unsaved changes
     * @returns Promise resolving to true/false
     */
    isDirty() {
        return __awaiter(this, void 0, void 0, function* () {
            const tab = yield this.enclosingItem.findElement(TextEditor.locators.TextEditor.activeTab);
            const klass = yield tab.getAttribute('class');
            return klass.indexOf('dirty') >= 0;
        });
    }
    /**
     * Saves the active editor
     * @returns Promise resolving when ctrl+s is invoked
     */
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            const inputarea = yield this.findElement(TextEditor.locators.Editor.inputArea);
            yield inputarea.sendKeys(selenium_webdriver_1.Key.chord(TextEditor.ctlKey, 's'));
        });
    }
    /**
     * Retrieve the Uri of the file opened in the active editor
     * @returns Promise resolving to editor's underlying Uri
     */
    getFileUri() {
        return __awaiter(this, void 0, void 0, function* () {
            const ed = yield this.findElement(TextEditor.locators.TextEditor.editorContainer);
            return ed.getAttribute(TextEditor.locators.TextEditor.dataUri);
        });
    }
    /**
     * Retrieve the path to the file opened in the active editor
     * @returns Promise resolving to editor's underlying file path
     */
    getFilePath() {
        return __awaiter(this, void 0, void 0, function* () {
            return url_1.fileURLToPath(yield this.getFileUri());
        });
    }
    /**
     * Open/Close the content assistant at the current position in the editor by sending the default
     * keyboard shortcut signal
     * @param open true to open, false to close
     * @returns Promise resolving to ContentAssist object when opening, void otherwise
     */
    toggleContentAssist(open) {
        return __awaiter(this, void 0, void 0, function* () {
            let isHidden = true;
            try {
                const assist = yield this.findElement(TextEditor.locators.ContentAssist.constructor);
                const klass = yield assist.getAttribute('class');
                const visibility = yield assist.getCssValue('visibility');
                isHidden = klass.indexOf('visible') < 0 || visibility === 'hidden';
            }
            catch (err) {
                isHidden = true;
            }
            const inputarea = yield this.findElement(TextEditor.locators.Editor.inputArea);
            if (open) {
                if (isHidden) {
                    yield inputarea.sendKeys(selenium_webdriver_1.Key.chord(selenium_webdriver_1.Key.CONTROL, selenium_webdriver_1.Key.SPACE));
                    yield this.getDriver().wait(selenium_webdriver_1.until.elementLocated(TextEditor.locators.ContentAssist.constructor), 2000);
                }
                const assist = yield new __1.ContentAssist(this).wait();
                yield this.getDriver().wait(() => { return assist.isLoaded(); }, 10000);
                return assist;
            }
            else {
                if (!isHidden) {
                    const col = (yield this.getCoordinates())[1];
                    yield inputarea.sendKeys(selenium_webdriver_1.Key.LEFT);
                    yield inputarea.sendKeys(selenium_webdriver_1.Key.RIGHT);
                    if (col < 2) {
                        yield inputarea.sendKeys(selenium_webdriver_1.Key.LEFT);
                    }
                }
            }
        });
    }
    /**
     * Get all text from the editor
     * @returns Promise resolving to editor text
     */
    getText() {
        return __awaiter(this, void 0, void 0, function* () {
            const inputarea = yield this.findElement(TextEditor.locators.Editor.inputArea);
            yield inputarea.sendKeys(selenium_webdriver_1.Key.chord(TextEditor.ctlKey, 'a'), selenium_webdriver_1.Key.chord(TextEditor.ctlKey, 'c'));
            const text = clipboard.readSync();
            yield inputarea.getDriver().actions().sendKeys(selenium_webdriver_1.Key.UP).perform();
            clipboard.writeSync('');
            return text;
        });
    }
    /**
     * Replace the contents of the editor with a given text
     * @param text text to type into the editor
     * @param formatText format the new text, default false
     * @returns Promise resolving once the new text is copied over
     */
    setText(text, formatText = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const inputarea = yield this.findElement(TextEditor.locators.Editor.inputArea);
            clipboard.writeSync(text);
            yield inputarea.sendKeys(selenium_webdriver_1.Key.chord(TextEditor.ctlKey, 'a'), selenium_webdriver_1.Key.chord(TextEditor.ctlKey, 'v'));
            clipboard.writeSync('');
            if (formatText) {
                yield this.formatDocument();
            }
        });
    }
    /**
     * Deletes all text within the editor
     * @returns Promise resolving once the text is deleted
     */
    clearText() {
        return __awaiter(this, void 0, void 0, function* () {
            const inputarea = yield this.findElement(TextEditor.locators.Editor.inputArea);
            yield inputarea.sendKeys(selenium_webdriver_1.Key.chord(TextEditor.ctlKey, 'a'));
            yield inputarea.sendKeys(selenium_webdriver_1.Key.BACK_SPACE);
        });
    }
    /**
     * Get text from a given line
     * @param line number of the line to retrieve
     * @returns Promise resolving to text at the given line number
     */
    getTextAtLine(line) {
        return __awaiter(this, void 0, void 0, function* () {
            const text = yield this.getText();
            const lines = text.split('\n');
            if (line < 1 || line > lines.length) {
                throw new Error(`Line number ${line} does not exist`);
            }
            return lines[line - 1];
        });
    }
    /**
     * Replace the contents of a line with a given text
     * @param line number of the line to edit
     * @param text text to set at the line
     * @returns Promise resolving when the text is typed in
     */
    setTextAtLine(line, text) {
        return __awaiter(this, void 0, void 0, function* () {
            if (line < 1 || line > (yield this.getNumberOfLines())) {
                throw new Error(`Line number ${line} does not exist`);
            }
            const lines = (yield this.getText()).split('\n');
            lines[line - 1] = text;
            yield this.setText(lines.join('\n'));
        });
    }
    /**
     * Get line number that contains the given text. Not suitable for multi line inputs.
     *
     * @param text text to search for
     * @param occurrence select which occurrence of the search text to look for in case there are multiple in the document, defaults to 1 (the first instance)
     *
     * @returns Number of the line that contains the start of the given text. -1 if no such text is found.
     * If occurrence number is specified, searches until it finds as many instances of the given text.
     * Returns the line number that holds the last occurrence found this way.
     */
    getLineOfText(text, occurrence = 1) {
        return __awaiter(this, void 0, void 0, function* () {
            let lineNum = -1;
            let found = 0;
            const lines = (yield this.getText()).split('\n');
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].includes(text)) {
                    found++;
                    lineNum = i + 1;
                    if (found >= occurrence) {
                        break;
                    }
                }
            }
            return lineNum;
        });
    }
    /**
     * Find and select a given text. Not usable for multi line selection.
     *
     * @param text text to select
     * @param occurrence specify which onccurrence of text to select if multiple are present in the document
     */
    selectText(text, occurrence = 1) {
        return __awaiter(this, void 0, void 0, function* () {
            const lineNum = yield this.getLineOfText(text, occurrence);
            if (lineNum < 1) {
                throw new Error(`Text '${text}' not found`);
            }
            const line = yield this.getTextAtLine(lineNum);
            const column = line.indexOf(text) + 1;
            yield this.moveCursor(lineNum, column);
            let action = this.getDriver().actions().keyDown(selenium_webdriver_1.Key.SHIFT);
            for (let i = 0; i < text.length; i++) {
                action = action.sendKeys(selenium_webdriver_1.Key.RIGHT);
            }
            action = action.keyUp(selenium_webdriver_1.Key.SHIFT);
            yield action.perform();
            yield new Promise(res => setTimeout(res, 500));
        });
    }
    /**
     * Get the text that is currently selected as string
     */
    getSelectedText() {
        return __awaiter(this, void 0, void 0, function* () {
            const selection = yield this.getSelection();
            if (!selection) {
                return '';
            }
            const menu = yield selection.openContextMenu();
            yield menu.select('Copy');
            yield new Promise(res => setTimeout(res, 500));
            return clipboard.read();
        });
    }
    /**
     * Get the selection block as a page object
     * @returns Selection page object
     */
    getSelection() {
        return __awaiter(this, void 0, void 0, function* () {
            const selection = yield this.findElements(TextEditor.locators.TextEditor.selection);
            if (selection.length < 1) {
                return undefined;
            }
            return new Selection(selection[0], this);
        });
    }
    openFindWidget() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getDriver().actions().sendKeys(selenium_webdriver_1.Key.chord(TextEditor.ctlKey, 'f')).perform();
            const widget = yield this.getDriver().wait(selenium_webdriver_1.until.elementLocated(TextEditor.locators.TextEditor.findWidget), 2000);
            yield this.getDriver().wait(selenium_webdriver_1.until.elementIsVisible(widget), 2000);
            return new FindWidget(widget, this);
        });
    }
    /**
     * Add the given text to the given coordinates
     * @param line number of the line to type into
     * @param column number of the column to start typing at
     * @param text text to add
     * @returns Promise resolving when the text is typed in
     */
    typeText(line, column, text) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.moveCursor(line, column);
            const inputarea = yield this.findElement(TextEditor.locators.Editor.inputArea);
            yield inputarea.sendKeys(text);
        });
    }
    /**
     * Move the cursor to the given coordinates
     * @param line line number to move to
     * @param column column number to move to
     * @returns Promise resolving when the cursor has reached the given coordinates
     */
    moveCursor(line, column) {
        return __awaiter(this, void 0, void 0, function* () {
            if (line < 1 || line > (yield this.getNumberOfLines())) {
                throw new Error(`Line number ${line} does not exist`);
            }
            if (column < 1) {
                throw new Error(`Column number ${column} does not exist`);
            }
            const inputarea = yield this.findElement(TextEditor.locators.Editor.inputArea);
            let coordinates = yield this.getCoordinates();
            const lineGap = coordinates[0] - line;
            const lineKey = lineGap >= 0 ? selenium_webdriver_1.Key.UP : selenium_webdriver_1.Key.DOWN;
            for (let i = 0; i < Math.abs(lineGap); i++) {
                yield inputarea.sendKeys(lineKey);
            }
            coordinates = yield this.getCoordinates();
            const columnGap = coordinates[1] - column;
            const columnKey = columnGap >= 0 ? selenium_webdriver_1.Key.LEFT : selenium_webdriver_1.Key.RIGHT;
            for (let i = 0; i < Math.abs(columnGap); i++) {
                yield inputarea.sendKeys(columnKey);
                if ((yield this.getCoordinates())[0] != coordinates[0]) {
                    throw new Error(`Column number ${column} is not accessible on line ${line}`);
                }
            }
        });
    }
    /**
     * Get number of lines in the editor
     * @returns Promise resolving to number of lines
     */
    getNumberOfLines() {
        return __awaiter(this, void 0, void 0, function* () {
            const lines = (yield this.getText()).split('\n');
            return lines.length;
        });
    }
    /**
     * Use the built-in 'Format Document' option to format the text
     * @returns Promise resolving when the Format Document command is invoked
     */
    formatDocument() {
        return __awaiter(this, void 0, void 0, function* () {
            const menu = yield this.openContextMenu();
            try {
                yield menu.select('Format Document');
            }
            catch (err) {
                console.log('Warn: Format Document not available for selected language');
                if (yield menu.isDisplayed()) {
                    yield menu.close();
                }
            }
        });
    }
    openContextMenu() {
        const _super = Object.create(null, {
            openContextMenu: { get: () => super.openContextMenu }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getDriver().actions().click(this, selenium_webdriver_1.Button.RIGHT).perform();
            const shadowRootHost = yield this.enclosingItem.findElements(selenium_webdriver_1.By.className('shadow-root-host'));
            if (shadowRootHost.length > 0) {
                const shadowRoot = yield this.getDriver().executeScript('return arguments[0].shadowRoot', shadowRootHost[0]);
                return new __1.ContextMenu(shadowRoot).wait();
            }
            return _super.openContextMenu.call(this);
        });
    }
    /**
     * Get the cursor's coordinates as an array of two numbers: `[line, column]`
     *
     * **Caution** line & column coordinates do not start at `0` but at `1`!
     */
    getCoordinates() {
        return __awaiter(this, void 0, void 0, function* () {
            const coords = [];
            const statusBar = new StatusBar_1.StatusBar();
            const coordinates = (yield statusBar.getCurrentPosition()).match(/\d+/g);
            for (const c of coordinates) {
                coords.push(+c);
            }
            return [coords[0], coords[1]];
        });
    }
    /**
     * Toggle breakpoint on a given line
     *
     * @param line target line number
     * @returns promise resolving to true when a breakpoint was added, false when removed or
     */
    toggleBreakpoint(line) {
        return __awaiter(this, void 0, void 0, function* () {
            const margin = yield this.findElement(TextEditor.locators.TextEditor.marginArea);
            const lineNum = yield margin.findElement(TextEditor.locators.TextEditor.lineNumber(line));
            yield this.getDriver().actions().mouseMove(lineNum).perform();
            const lineOverlay = yield margin.findElement(TextEditor.locators.TextEditor.lineOverlay(line));
            const breakPoint = yield lineOverlay.findElements(TextEditor.locators.TextEditor.breakPoint);
            if (breakPoint.length > 0) {
                yield breakPoint[0].click();
                yield new Promise(res => setTimeout(res, 200));
                return false;
            }
            const noBreak = yield lineOverlay.findElements(TextEditor.locators.TextEditor.debugHint);
            if (noBreak.length > 0) {
                yield noBreak[0].click();
                yield new Promise(res => setTimeout(res, 200));
                return true;
            }
            return false;
        });
    }
}
exports.TextEditor = TextEditor;
/**
 * Text selection block
 */
class Selection extends ElementWithContextMenu_1.ElementWithContexMenu {
    constructor(el, editor) {
        super(el, editor);
    }
    openContextMenu() {
        const _super = Object.create(null, {
            openContextMenu: { get: () => super.openContextMenu }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const ed = this.getEnclosingElement();
            yield this.getDriver().actions().click(this, selenium_webdriver_1.Button.RIGHT).perform();
            const shadowRootHost = yield ed.getEnclosingElement().findElements(selenium_webdriver_1.By.className('shadow-root-host'));
            if (shadowRootHost.length > 0) {
                const shadowRoot = yield this.getDriver().executeScript('return arguments[0].shadowRoot', shadowRootHost[0]);
                return new __1.ContextMenu(shadowRoot).wait();
            }
            return _super.openContextMenu.call(this);
        });
    }
}
/**
 * Text Editor's Find Widget
 */
class FindWidget extends AbstractElement_1.AbstractElement {
    constructor(element, editor) {
        super(element, editor);
    }
    /**
     * Toggle between find and replace mode
     * @param replace true for replace, false for find
     */
    toggleReplace(replace) {
        return __awaiter(this, void 0, void 0, function* () {
            const btn = yield this.findElement(FindWidget.locators.FindWidget.toggleReplace);
            const klass = yield btn.getAttribute('class');
            if (replace && klass.includes('collapsed') || !replace && !klass.includes('collapsed')) {
                yield btn.sendKeys(selenium_webdriver_1.Key.SPACE);
                const repl = yield this.getDriver().wait(selenium_webdriver_1.until.elementLocated(FindWidget.locators.FindWidget.replacePart), 2000);
                if (replace) {
                    yield this.getDriver().wait(selenium_webdriver_1.until.elementIsVisible(repl), 2000);
                }
                else {
                    yield this.getDriver().wait(selenium_webdriver_1.until.elementIsNotVisible(repl), 2000);
                }
            }
        });
    }
    /**
     * Set text in the search box
     * @param text text to fill in
     */
    setSearchText(text) {
        return __awaiter(this, void 0, void 0, function* () {
            const findPart = yield this.findElement(FindWidget.locators.FindWidget.findPart);
            yield this.setText(text, findPart);
        });
    }
    /**
     * Get text from Find input box
     * @returns value of find input as string
     */
    getSearchText() {
        return __awaiter(this, void 0, void 0, function* () {
            const findPart = yield this.findElement(FindWidget.locators.FindWidget.findPart);
            return this.getInputText(findPart);
        });
    }
    /**
     * Set text in the replace box. Will toggle replace mode on if called in find mode.
     * @param text text to fill in
     */
    setReplaceText(text) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.toggleReplace(true);
            const replacePart = yield this.findElement(FindWidget.locators.FindWidget.replacePart);
            yield this.setText(text, replacePart);
        });
    }
    /**
     * Get text from Replace input box
     * @returns value of replace input as string
     */
    getReplaceText() {
        return __awaiter(this, void 0, void 0, function* () {
            const replacePart = yield this.findElement(FindWidget.locators.FindWidget.replacePart);
            return this.getInputText(replacePart);
        });
    }
    /**
     * Click 'Next match'
     */
    nextMatch() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.clickButton('Next match', 'find');
        });
    }
    /**
     * Click 'Previous match'
     */
    previousMatch() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.clickButton('Previous match', 'find');
        });
    }
    /**
     * Click 'Replace'. Only works in replace mode.
     */
    replace() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.clickButton('Replace', 'replace');
        });
    }
    /**
     * Click 'Replace All'. Only works in replace mode.
     */
    replaceAll() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.clickButton('Replace All', 'replace');
        });
    }
    /**
     * Close the widget.
     */
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.clickButton('Close', 'find');
        });
    }
    /**
     * Get the number of results as an ordered pair of numbers
     * @returns pair in form of [current result index, total number of results]
     */
    getResultCount() {
        return __awaiter(this, void 0, void 0, function* () {
            const count = yield this.findElement(FindWidget.locators.FindWidget.matchCount);
            const text = yield count.getText();
            if (text.includes('No results')) {
                return [0, 0];
            }
            const numbers = text.split(' of ');
            return [+numbers[0], +numbers[1]];
        });
    }
    /**
     * Toggle the search to match case
     * @param toggle true to turn on, false to turn off
     */
    toggleMatchCase(toggle) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.toggleControl('Match Case', 'find', toggle);
        });
    }
    /**
     * Toggle the search to match whole words
     * @param toggle true to turn on, false to turn off
     */
    toggleMatchWholeWord(toggle) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.toggleControl('Match Whole Word', 'find', toggle);
        });
    }
    /**
     * Toggle the search to use regular expressions
     * @param toggle true to turn on, false to turn off
     */
    toggleUseRegularExpression(toggle) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.toggleControl('Use Regular Expression', 'find', toggle);
        });
    }
    /**
     * Toggle the replace to preserve case
     * @param toggle true to turn on, false to turn off
     */
    togglePreserveCase(toggle) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.toggleControl('Preserve Case', 'replace', toggle);
        });
    }
    toggleControl(title, part, toggle) {
        return __awaiter(this, void 0, void 0, function* () {
            let element;
            if (part === 'find') {
                element = yield this.findElement(FindWidget.locators.FindWidget.findPart);
            }
            if (part === 'replace') {
                element = yield this.findElement(FindWidget.locators.FindWidget.replacePart);
                yield this.toggleReplace(true);
            }
            const control = yield element.findElement(FindWidget.locators.FindWidget.checkbox(title));
            const checked = yield control.getAttribute('aria-checked');
            if ((toggle && checked !== 'true') || (!toggle && checked === 'true')) {
                yield control.click();
            }
        });
    }
    clickButton(title, part) {
        return __awaiter(this, void 0, void 0, function* () {
            let element;
            if (part === 'find') {
                element = yield this.findElement(FindWidget.locators.FindWidget.findPart);
            }
            if (part === 'replace') {
                element = yield this.findElement(FindWidget.locators.FindWidget.replacePart);
                yield this.toggleReplace(true);
            }
            const btn = yield element.findElement(FindWidget.locators.FindWidget.button(title));
            yield btn.click();
            yield this.getDriver().sleep(100);
        });
    }
    setText(text, composite) {
        return __awaiter(this, void 0, void 0, function* () {
            const input = yield composite.findElement(FindWidget.locators.FindWidget.input);
            yield input.clear();
            yield input.sendKeys(text);
        });
    }
    getInputText(composite) {
        return __awaiter(this, void 0, void 0, function* () {
            const input = yield composite.findElement(FindWidget.locators.FindWidget.content);
            return input.getAttribute('innerHTML');
        });
    }
}
exports.FindWidget = FindWidget;
//# sourceMappingURL=TextEditor.js.map