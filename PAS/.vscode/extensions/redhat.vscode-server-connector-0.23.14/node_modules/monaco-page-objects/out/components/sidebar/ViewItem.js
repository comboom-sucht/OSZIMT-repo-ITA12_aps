"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ViewItemAction = exports.TreeItem = exports.ViewItem = void 0;
const ElementWithContextMenu_1 = require("../ElementWithContextMenu");
const AbstractElement_1 = require("../AbstractElement");
/**
 * Arbitrary item in the side bar view
 */
class ViewItem extends ElementWithContextMenu_1.ElementWithContexMenu {
    /**
     * Select the item in the view.
     * Note that selecting the item will toggle its expand state when applicable.
     * @returns Promise resolving when the item has been clicked
     */
    select() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.click();
        });
    }
}
exports.ViewItem = ViewItem;
/**
 * Abstract representation of a row in the tree inside a view content section
 */
class TreeItem extends ViewItem {
    /**
     * Retrieves the label of this view item
     */
    getLabel() {
        return __awaiter(this, void 0, void 0, function* () {
            return '';
        });
    }
    /**
     * Retrieves the tooltip of this TreeItem.
     * @returns A promise resolving to the tooltip or undefined if the TreeItem has no tooltip.
     */
    getTooltip() {
        return __awaiter(this, void 0, void 0, function* () {
            return undefined;
        });
    }
    /**
     * Finds if the item has children by actually counting the child items
     * Note that this will expand the item if it was collapsed
     * @returns Promise resolving to true/false
     */
    hasChildren() {
        return __awaiter(this, void 0, void 0, function* () {
            const children = yield this.getChildren();
            return children && children.length > 0;
        });
    }
    /**
     * Expands the current item, if it can be expanded and is collapsed.
     */
    expand() {
        return __awaiter(this, void 0, void 0, function* () {
            if ((yield this.isExpandable()) && !(yield this.isExpanded())) {
                yield (yield this.findTwistie()).click();
            }
        });
    }
    /**
     * Find a child item with the given name
     * @returns Promise resolving to TreeItem object if the child item exists, undefined otherwise
     */
    findChildItem(name) {
        return __awaiter(this, void 0, void 0, function* () {
            const children = yield this.getChildren();
            for (const item of children) {
                if ((yield item.getLabel()) === name) {
                    return item;
                }
            }
        });
    }
    /**
     * Collapse the item if expanded
     */
    collapse() {
        return __awaiter(this, void 0, void 0, function* () {
            if ((yield this.isExpandable()) && (yield this.isExpanded())) {
                yield (yield this.findTwistie()).click();
            }
        });
    }
    /**
     * Find all action buttons bound to the view item
     *
     * @returns array of ViewItemAction objects, empty array if item has no
     * actions associated
     */
    getActionButtons() {
        return __awaiter(this, void 0, void 0, function* () {
            let container;
            try {
                container = yield this.findElement(TreeItem.locators.TreeItem.actions);
            }
            catch (err) {
                return [];
            }
            const actions = [];
            const items = yield container.findElements(TreeItem.locators.TreeItem.actionLabel);
            for (const item of items) {
                const label = yield item.getAttribute(TreeItem.locators.TreeItem.actionTitle);
                actions.push(new ViewItemAction(label, this));
            }
            return actions;
        });
    }
    /**
     * Find action button for view item by label
     * @param label label of the button to search by
     *
     * @returns ViewItemAction object if such button exists, undefined otherwise
     */
    getActionButton(label) {
        return __awaiter(this, void 0, void 0, function* () {
            const actions = yield this.getActionButtons();
            if (actions.length > 0) {
                return actions.find((item) => { return item.getLabel().indexOf(label) > -1; });
            }
            else {
                return undefined;
            }
        });
    }
    /**
     * Find all child elements of a tree item
     * @param locator locator of a given type of tree item
     */
    getChildItems(locator) {
        return __awaiter(this, void 0, void 0, function* () {
            const items = [];
            yield this.expand();
            const rows = yield this.enclosingItem.findElements(locator);
            const baseIndex = +(yield this.getAttribute(TreeItem.locators.ViewSection.index));
            const baseLevel = +(yield this.getAttribute(TreeItem.locators.ViewSection.level));
            for (const row of rows) {
                const level = +(yield row.getAttribute(TreeItem.locators.ViewSection.level));
                const index = +(yield row.getAttribute(TreeItem.locators.ViewSection.index));
                if (index <= baseIndex) {
                    continue;
                }
                if (level > baseLevel + 1) {
                    continue;
                }
                if (level <= baseLevel) {
                    break;
                }
                items.push(row);
            }
            return items;
        });
    }
    findTwistie() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.findElement(TreeItem.locators.TreeItem.twistie);
        });
    }
}
exports.TreeItem = TreeItem;
/**
 * Action button bound to a view item
 */
class ViewItemAction extends AbstractElement_1.AbstractElement {
    constructor(label, viewItem) {
        super(ViewItemAction.locators.ViewSection.actionConstructor(label), viewItem);
        this.label = label;
    }
    /**
     * Get label of the action button
     */
    getLabel() {
        return this.label;
    }
}
exports.ViewItemAction = ViewItemAction;
//# sourceMappingURL=ViewItem.js.map