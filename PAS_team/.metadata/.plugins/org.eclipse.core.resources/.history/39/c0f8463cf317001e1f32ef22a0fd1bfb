import java.awt.Window.Type;
import java.io.File;
import java.io.IOException;
import java.util.HashMap;

public class UserManagement {
	
	private HashMap<String, String> users = new HashMap<String, String>();
	private File  filename = new File("um.oszuser");
	private String password = "v$Eez6!BX&cA3ZJ%Ztw87%MwbpbsAkjz2PaECW&grSq@DGBHisgjJwC@Kq@R4Ufz";
	private SecureEnclave se = new SecureEnclave();
	
	public UserManagement() {
		loadUsers();
	}
	
	public void addUser(String username, String password) {
		users.put(username, password);
		saveUsers();
	}
	
	public void removeUser(String username) {
		users.remove(username);
		saveUsers();
	}
	
	public boolean userExists(String username, String password) {
	    String storedPassword = users.get(username);
	    return storedPassword != null && storedPassword.equals(password);
	}

	
	private void loadUsers() {
		try {
			byte[] encryptedData = FileHandler.readFile(filename);
			String decryptedText = se.decrypt(password, encryptedData);
			// Deserialize the decrypted text into a HashMap
			users = HashMapFrom(decryptedText);
		} catch (IOException e) {
			// Handle file read error
			e.printStackTrace();
		} catch (SecurityException e) {
			// Handle decryption error
			e.printStackTrace();
		}
	}
	
	private void saveUsers() {
		// Serialize the users HashMap into a string
		// Encrypt the serialized users data
		System.out.print(users.toString());
		byte[] encryptedData = se.encrypt(password, users.toString());
		try {
			FileHandler.writeFile(filename, encryptedData);
		} catch (IOException e) {
			// Handle file write error
			e.printStackTrace();
		}
	}
	
	
	private HashMap<String, String> HashMapFrom(String s) {
	    HashMap<String, String> base = new HashMap<>(); // Ergebnis
	    int dismiss = 0; // Dismiss-Tracker
	    StringBuilder tmpVal = new StringBuilder(); // Zwischenspeicher für jeden Wert
	    StringBuilder tmpKey = new StringBuilder(); // Zwischenspeicher für jeden Schlüssel

	    for (String next : s.split("")) { // Verarbeite jeden Wert
	        if (dismiss == 0) { // Wenn nicht gerade ein Wert geschrieben wird
	            if (next.equals("=")) { // Beginne mit dem Schreiben des Werts
	                dismiss = 1; // Aktualisiere den Tracker
	            } else {
	                tmpKey.append(next); // Schreibe den Schlüssel
	            }
	        } else {
	            if (next.equals("{")) { // Wenn es sich um einen Wert handelt, der zu ignorieren ist
	                dismiss++;
	            } else if (next.equals("}")) { // Wert abgeschlossen, nun muss der Fokus wieder auf den Schlüssel gelegt werden
	                dismiss--;
	            } else if (next.equals(",") && dismiss == 1) { // Deklaration endet
	                // Hier muss etwas hinzugefügt werden, um den Typ zu korrigieren
	                Object objVal = tmpVal.toString(); // Wert korrigieren
	                base.put(tmpKey.toString(), objVal.toString()); // Deklaration
	                tmpKey = new StringBuilder();
	                tmpVal = new StringBuilder();
	                dismiss--;
	                continue; // Weiter mit dem nächsten Wert
	            }
	            tmpVal.append(next); // Schreibe den Wert
	        }
	    }

	    Object objVal = tmpVal.toString(); // Ebenfalls hier
	    base.put(tmpKey.toString(), objVal.toString()); // Restliche Werte
	    return base;
	}

}

